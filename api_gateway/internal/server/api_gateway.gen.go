//go:build go1.22

// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package server

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for PermissionLevel.
const (
	Editor PermissionLevel = "editor"
	Owner  PermissionLevel = "owner"
	Viewer PermissionLevel = "viewer"
)

// Defines values for PrincipalPrincipalType.
const (
	PrincipalPrincipalTypeGuest PrincipalPrincipalType = "guest"
	PrincipalPrincipalTypeUser  PrincipalPrincipalType = "user"
)

// CreatedAt Timestamp measured in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
type CreatedAt = int64

// Document defines model for Document.
type Document struct {
	// CreatedAt Timestamp measured in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
	CreatedAt           CreatedAt          `json:"createdAt"`
	DocumentDescription string             `json:"documentDescription"`
	DocumentId          openapi_types.UUID `json:"documentId"`
	DocumentName        string             `json:"documentName"`

	// LastModifiedAt Timestamp measured in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
	LastModifiedAt LastModifiedAt `json:"lastModifiedAt"`
}

// Error defines model for Error.
type Error struct {
	Message *string `json:"message,omitempty"`
}

// LastModifiedAt Timestamp measured in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
type LastModifiedAt = int64

// Permission defines model for Permission.
type Permission struct {
	// CreatedAt Timestamp measured in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
	CreatedAt  CreatedAt          `json:"createdAt"`
	CreatedBy  openapi_types.UUID `json:"createdBy"`
	DocumentId openapi_types.UUID `json:"documentId"`

	// LastModifiedAt Timestamp measured in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
	LastModifiedAt  LastModifiedAt  `json:"lastModifiedAt"`
	PermissionLevel PermissionLevel `json:"permissionLevel"`
	Principal       Principal       `json:"principal"`
}

// PermissionLevel defines model for PermissionLevel.
type PermissionLevel string

// Principal defines model for Principal.
type Principal struct {
	PrincipalId   openapi_types.UUID     `json:"principalId"`
	PrincipalType PrincipalPrincipalType `json:"principalType"`
}

// PrincipalPrincipalType defines model for Principal.PrincipalType.
type PrincipalPrincipalType string

// User defines model for User.
type User struct {
	Email        string             `json:"email"`
	MaxDocuments int32              `json:"maxDocuments"`
	UserId       openapi_types.UUID `json:"userId"`
	UserName     string             `json:"userName"`
}

// DocumentId defines model for DocumentId.
type DocumentId = openapi_types.UUID

// PrincipalId defines model for PrincipalId.
type PrincipalId = openapi_types.UUID

// UserId defines model for UserId.
type UserId = openapi_types.UUID

// BadRequest defines model for BadRequest.
type BadRequest = Error

// Unauthenticated defines model for Unauthenticated.
type Unauthenticated = Error

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// PostAuthLoginJSONBody defines parameters for PostAuthLogin.
type PostAuthLoginJSONBody struct {
	Password string `json:"password"`
	UserName string `json:"userName"`
}

// DeleteDocumentJSONBody defines parameters for DeleteDocument.
type DeleteDocumentJSONBody struct {
	DocumentIds []openapi_types.UUID `json:"documentIds"`
}

// GetDocumentParams defines parameters for GetDocument.
type GetDocumentParams struct {
	// Cursor a cursor can optionally be supplied for pagination
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit the number of documents to retrieve in a page
	Limit *string `form:"limit,omitempty" json:"limit,omitempty"`
}

// PostDocumentJSONBody defines parameters for PostDocument.
type PostDocumentJSONBody struct {
	DocumentDescription *string            `json:"documentDescription,omitempty"`
	DocumentName        *string            `json:"documentName,omitempty"`
	UserId              openapi_types.UUID `json:"userId"`
}

// PutDocumentDocumentIdJSONBody defines parameters for PutDocumentDocumentId.
type PutDocumentDocumentIdJSONBody struct {
	DocumentDescription *string `json:"documentDescription,omitempty"`
	DocumentName        *string `json:"documentName,omitempty"`
}

// GetDocumentDocumentIdPermissionParams defines parameters for GetDocumentDocumentIdPermission.
type GetDocumentDocumentIdPermissionParams struct {
	// Cursor a cursor can optionally be supplied for pagination
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit the number of documents to retrieve in a page
	Limit *string `form:"limit,omitempty" json:"limit,omitempty"`
}

// PostDocumentDocumentIdPermissionJSONBody defines parameters for PostDocumentDocumentIdPermission.
type PostDocumentDocumentIdPermissionJSONBody struct {
	UserIdToShare openapi_types.UUID `json:"userIdToShare"`
}

// PutDocumentDocumentIdPermissionPrincipalPrincipalIdJSONBody defines parameters for PutDocumentDocumentIdPermissionPrincipalPrincipalId.
type PutDocumentDocumentIdPermissionPrincipalPrincipalIdJSONBody struct {
	PermissionLevel PermissionLevel `json:"permissionLevel"`
}

// PostUserJSONBody defines parameters for PostUser.
type PostUserJSONBody struct {
	MaxDocuments *int32              `json:"maxDocuments,omitempty"`
	Password     string              `json:"password"`
	UserEmail    openapi_types.Email `json:"userEmail"`
	UserName     string              `json:"userName"`
}

// PutUserUserIdJSONBody defines parameters for PutUserUserId.
type PutUserUserIdJSONBody struct {
	NewPassword string `json:"newPassword"`
	OldPassword string `json:"oldPassword"`
}

// PostAuthLoginJSONRequestBody defines body for PostAuthLogin for application/json ContentType.
type PostAuthLoginJSONRequestBody PostAuthLoginJSONBody

// DeleteDocumentJSONRequestBody defines body for DeleteDocument for application/json ContentType.
type DeleteDocumentJSONRequestBody DeleteDocumentJSONBody

// PostDocumentJSONRequestBody defines body for PostDocument for application/json ContentType.
type PostDocumentJSONRequestBody PostDocumentJSONBody

// PutDocumentDocumentIdJSONRequestBody defines body for PutDocumentDocumentId for application/json ContentType.
type PutDocumentDocumentIdJSONRequestBody PutDocumentDocumentIdJSONBody

// PostDocumentDocumentIdPermissionJSONRequestBody defines body for PostDocumentDocumentIdPermission for application/json ContentType.
type PostDocumentDocumentIdPermissionJSONRequestBody PostDocumentDocumentIdPermissionJSONBody

// PutDocumentDocumentIdPermissionPrincipalPrincipalIdJSONRequestBody defines body for PutDocumentDocumentIdPermissionPrincipalPrincipalId for application/json ContentType.
type PutDocumentDocumentIdPermissionPrincipalPrincipalIdJSONRequestBody PutDocumentDocumentIdPermissionPrincipalPrincipalIdJSONBody

// PostUserJSONRequestBody defines body for PostUser for application/json ContentType.
type PostUserJSONRequestBody PostUserJSONBody

// PutUserUserIdJSONRequestBody defines body for PutUserUserId for application/json ContentType.
type PutUserUserIdJSONRequestBody PutUserUserIdJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// get a token
	// (POST /auth/login)
	PostAuthLogin(w http.ResponseWriter, r *http.Request)
	// batch delete endpoint for deleting lists of documents
	// (DELETE /document)
	DeleteDocument(w http.ResponseWriter, r *http.Request)
	// get all the documents that a given user has owner permissions on
	// (GET /document)
	GetDocument(w http.ResponseWriter, r *http.Request, params GetDocumentParams)
	// create a new document for a user
	// (POST /document)
	PostDocument(w http.ResponseWriter, r *http.Request)
	// delete a document
	// (DELETE /document/{documentId})
	DeleteDocumentDocumentId(w http.ResponseWriter, r *http.Request, documentId DocumentId)
	// get one document
	// (GET /document/{documentId})
	GetDocumentDocumentId(w http.ResponseWriter, r *http.Request, documentId DocumentId)
	// update one document
	// (PUT /document/{documentId})
	PutDocumentDocumentId(w http.ResponseWriter, r *http.Request, documentId DocumentId)
	// get all the users that have permission on a document, this is only meant to be called by users that have owner permissions on that document
	// (GET /document/{documentId}/permission)
	GetDocumentDocumentIdPermission(w http.ResponseWriter, r *http.Request, documentId DocumentId, params GetDocumentDocumentIdPermissionParams)
	// create a permission on a document either by sharing the document with an existing user or creating a new guest user for that document
	// (POST /document/{documentId}/permission)
	PostDocumentDocumentIdPermission(w http.ResponseWriter, r *http.Request, documentId DocumentId)
	// delete a user or guests permissions on a document
	// (DELETE /document/{documentId}/permission/principal/{principalId})
	DeleteDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request, documentId DocumentId, principalId PrincipalId)
	// get the permission of a principal on a document
	// (GET /document/{documentId}/permission/principal/{principalId})
	GetDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request, documentId DocumentId, principalId PrincipalId)
	// update the permission level of a user or a guest on a document
	// (PUT /document/{documentId}/permission/principal/{principalId})
	PutDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request, documentId DocumentId, principalId PrincipalId)
	// create a user
	// (POST /user)
	PostUser(w http.ResponseWriter, r *http.Request)
	// deactivate a user
	// (DELETE /user/{userId})
	DeleteUserUserId(w http.ResponseWriter, r *http.Request, userId UserId)
	// get a user
	// (GET /user/{userId})
	GetUserUserId(w http.ResponseWriter, r *http.Request, userId UserId)
	// update a user including the users password
	// (PUT /user/{userId})
	PutUserUserId(w http.ResponseWriter, r *http.Request, userId UserId)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// PostAuthLogin operation middleware
func (siw *ServerInterfaceWrapper) PostAuthLogin(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuthLogin(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteDocument operation middleware
func (siw *ServerInterfaceWrapper) DeleteDocument(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDocument(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDocument operation middleware
func (siw *ServerInterfaceWrapper) GetDocument(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDocumentParams

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", r.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cursor", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDocument(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostDocument operation middleware
func (siw *ServerInterfaceWrapper) PostDocument(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDocument(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteDocumentDocumentId operation middleware
func (siw *ServerInterfaceWrapper) DeleteDocumentDocumentId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDocumentDocumentId(w, r, documentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDocumentDocumentId operation middleware
func (siw *ServerInterfaceWrapper) GetDocumentDocumentId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDocumentDocumentId(w, r, documentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PutDocumentDocumentId operation middleware
func (siw *ServerInterfaceWrapper) PutDocumentDocumentId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutDocumentDocumentId(w, r, documentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDocumentDocumentIdPermission operation middleware
func (siw *ServerInterfaceWrapper) GetDocumentDocumentIdPermission(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDocumentDocumentIdPermissionParams

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", r.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cursor", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDocumentDocumentIdPermission(w, r, documentId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostDocumentDocumentIdPermission operation middleware
func (siw *ServerInterfaceWrapper) PostDocumentDocumentIdPermission(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDocumentDocumentIdPermission(w, r, documentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteDocumentDocumentIdPermissionPrincipalPrincipalId operation middleware
func (siw *ServerInterfaceWrapper) DeleteDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	// ------------- Path parameter "principalId" -------------
	var principalId PrincipalId

	err = runtime.BindStyledParameterWithOptions("simple", "principalId", r.PathValue("principalId"), &principalId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "principalId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDocumentDocumentIdPermissionPrincipalPrincipalId(w, r, documentId, principalId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDocumentDocumentIdPermissionPrincipalPrincipalId operation middleware
func (siw *ServerInterfaceWrapper) GetDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	// ------------- Path parameter "principalId" -------------
	var principalId PrincipalId

	err = runtime.BindStyledParameterWithOptions("simple", "principalId", r.PathValue("principalId"), &principalId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "principalId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDocumentDocumentIdPermissionPrincipalPrincipalId(w, r, documentId, principalId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PutDocumentDocumentIdPermissionPrincipalPrincipalId operation middleware
func (siw *ServerInterfaceWrapper) PutDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	// ------------- Path parameter "principalId" -------------
	var principalId PrincipalId

	err = runtime.BindStyledParameterWithOptions("simple", "principalId", r.PathValue("principalId"), &principalId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "principalId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutDocumentDocumentIdPermissionPrincipalPrincipalId(w, r, documentId, principalId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostUser operation middleware
func (siw *ServerInterfaceWrapper) PostUser(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostUser(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteUserUserId operation middleware
func (siw *ServerInterfaceWrapper) DeleteUserUserId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId UserId

	err = runtime.BindStyledParameterWithOptions("simple", "userId", r.PathValue("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "userId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUserUserId(w, r, userId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetUserUserId operation middleware
func (siw *ServerInterfaceWrapper) GetUserUserId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId UserId

	err = runtime.BindStyledParameterWithOptions("simple", "userId", r.PathValue("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "userId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUserUserId(w, r, userId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PutUserUserId operation middleware
func (siw *ServerInterfaceWrapper) PutUserUserId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId UserId

	err = runtime.BindStyledParameterWithOptions("simple", "userId", r.PathValue("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "userId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutUserUserId(w, r, userId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("POST "+options.BaseURL+"/auth/login", wrapper.PostAuthLogin)
	m.HandleFunc("DELETE "+options.BaseURL+"/document", wrapper.DeleteDocument)
	m.HandleFunc("GET "+options.BaseURL+"/document", wrapper.GetDocument)
	m.HandleFunc("POST "+options.BaseURL+"/document", wrapper.PostDocument)
	m.HandleFunc("DELETE "+options.BaseURL+"/document/{documentId}", wrapper.DeleteDocumentDocumentId)
	m.HandleFunc("GET "+options.BaseURL+"/document/{documentId}", wrapper.GetDocumentDocumentId)
	m.HandleFunc("PUT "+options.BaseURL+"/document/{documentId}", wrapper.PutDocumentDocumentId)
	m.HandleFunc("GET "+options.BaseURL+"/document/{documentId}/permission", wrapper.GetDocumentDocumentIdPermission)
	m.HandleFunc("POST "+options.BaseURL+"/document/{documentId}/permission", wrapper.PostDocumentDocumentIdPermission)
	m.HandleFunc("DELETE "+options.BaseURL+"/document/{documentId}/permission/principal/{principalId}", wrapper.DeleteDocumentDocumentIdPermissionPrincipalPrincipalId)
	m.HandleFunc("GET "+options.BaseURL+"/document/{documentId}/permission/principal/{principalId}", wrapper.GetDocumentDocumentIdPermissionPrincipalPrincipalId)
	m.HandleFunc("PUT "+options.BaseURL+"/document/{documentId}/permission/principal/{principalId}", wrapper.PutDocumentDocumentIdPermissionPrincipalPrincipalId)
	m.HandleFunc("POST "+options.BaseURL+"/user", wrapper.PostUser)
	m.HandleFunc("DELETE "+options.BaseURL+"/user/{userId}", wrapper.DeleteUserUserId)
	m.HandleFunc("GET "+options.BaseURL+"/user/{userId}", wrapper.GetUserUserId)
	m.HandleFunc("PUT "+options.BaseURL+"/user/{userId}", wrapper.PutUserUserId)

	return m
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xaW3PbuhH+Kxi0D+0MbUm24ovecjk9deummh57+pDxA0SuRCQkwACgZNXj/95ZgBdQ",
	"oiTKUjqN2kweLBJY7C6+3f0W4AsNZZpJAcJoOnqhGVMsBQPK/vokwzwFYe4i/AXPLM0SoCM6uLiE4bur",
	"6zO4uZ2cDS6iyzM2fHd1Nry4uhoMB9fDfr9PA8oFHdGMmZgGVLAUZ0a1xIAq+J5zBREdGZVDQHUYQ8pw",
	"qalUKTN0RPOc40izzHC2NoqLGX19DehYcRHyjCXH0y3zRB6m3KMGdTy9ciftEJVecbLOpNBgN/YDi/4B",
	"33PQBn+FUhgQ9k+WZQkPmeFS9L5qKfBZvczvFUzpiP6uV4Om597q3i9KSeWWikCHimcohI5wLVIuhr4R",
	"LDcxCIPLQNRh/cqHLzQFrdkMTfOEcClIyrXmYkakIlzMWcIjXOtAzd8316jcX1khFf/X200wMdcEN5dw",
	"TYQ0hCWJXEBEjCQZKNxTYsew0Cp0uEGfpSHv3SIWp8UElPdRAW7He2tCc9YDT0EblmYkBaZzBRHh6PEk",
	"4RpCKSJNNBchkEfBnwlkMozJH/7CRM7UkgwCMri97gek3x/Z/+Tx4eMfaVC7ZHDdvxjeXF708V9QQ5kL",
	"czWsscyFgRko9EKZlmzCUjIDZbjDdehbsc1FtbnopELeJ9/sl9UgCvzktTvm6uGfbRi3yEuYNn+TEZ/y",
	"LirfN0e7mC4TwpdmZm0s3W5g4DlrTZWnyhw5+Qqh9ZJD1ZrLKzy/tCTCNSH3ayb/l2NtDMrmFgeJY6Ct",
	"mPVhuReIOmLuMEgFNKvMvYc5JLsEjFeGo4Syiu6cWw1chXItImjCelU735l743m8biqIPEUF5hwWoBA4",
	"ETcS/5ALAcoTU3t87NvbxEfW5Cg7N68a/2Df1PpgkaABndka+tTGOFrd53zWENrmCGQr68pDynjSmrZS",
	"9lxmYN2wiwtzedEaRXlFiHY6AYduyJgrdla8qJoSFFqv6LhuNNY+CHPFzfI3hKMzeQJMgcKqX//6U6nv",
	"1wXiyoIXJbm3tQGxMZkruVxMZUtis4U840RnEJIIplyAJiYGgm5SUxYCmYBZAAj7FIfOmIEFWxImIvss",
	"TDgIc04eYiDvx3fk1+I9d4KyfJLwkIAwaplJLgyZSmXfzJniMtdkwsJvICKS8lBJDWrOQ9Dn5M4QqcIY",
	"tFHMgLZEB7TRSETSPDE8S6A5x6qUKTnnEf4goYxB87lvTLm2UxpF5Rp3yHBj+bBvwJ8fHsaVc/i0YE80",
	"oHNQLvXS/vngvI/4kBkIlnE6opfn/fNLRDgzsd2/HnKyXiJn3CVr6egtotoKRATSsdQGt/jeDnOIAm0+",
	"yGi5FxdeCXWm9UKqqDVg9oN0geRKYgt61/j8Rb9/gPLwnHEF+k50jGYjv4HYbYwbFnji20xZ5ah//2sj",
	"POnoy1NAdZ6mTC3piM7AEEZK0YbNNC5lY/YJ5/UijxxGkICBdQx8ss8rGnksENS1yv7kBlLdKecVD5hS",
	"bLmF2OlODsSgK+cQHmFuYMYPxQUTRhPnm/W2ch1aw/Vs9lmSj4WPXgM6dOhrK/aVqJ7Xctopg91TVltF",
	"O++y67yiObNgquAzYSaMC9sJiKjOk/YZtpAJx9Qnp5UTtQc0r6i8BgjGdXD9CsZDln+g8mXVjYyEudJS",
	"kZAJIu1TliRLMgGicwQeRFa3jM24KHOiPSH4noNa1kcETgz1G8S12HxpwYnI0wmohrGYqRUYxcGmc8Jw",
	"ddiwbsJTbrYu+3TUTFXYua05a4beNgJa7VLXCNSdE9hPFRM2pSYJ8RNHkTUYmfE5CHdKETNNLA8mNQ/X",
	"RIqN4bG5AP+w1Nu1hd/Yk3dmqu1ktFuxHuxlqXd45HeDtH8xjW5uJtEZvIsuz4a3cHN2y8Lh2bvL68Fw",
	"EPYvbm+Grq1oL1L7G+nNPclIcB0kYUTAoq6hmIEZKXqwNqT7tKP3UjvptTsH+dQ8F99Vf386zxYVl1Ve",
	"fXNN3eap/tFOs+vacCIJXgrY7fsVstK2YD2k5+0Elvksb0v2+aaNe1vWT7kYe+lsEPyYOvDakWdnTDmu",
	"2CDd7YTbSBLGTFgu9QbK/dOhLs8iTKYdgLcxf/ayxulr99Tgndr+n4I/Hcg/OlNwjxZ2JuHeTu2i4b74",
	"kyfiSDcKEh6zOXiUm0jh1dHAXRFyJOLJkqTA3GHbBEjIkgQiMlmuCWtj8e51S6SOfbcfXCR2tgQbgvg4",
	"bYJj6Q/yt5gpeCvJL6f/iIO5XfXNXgHscZJ+F1ldo39yd6i9294TZvWbYogANzEojBQdM/REs54vuIkJ",
	"EwSeubZHRLYdxpqBkvGB6xjs5riX7vS7S0B1KX696hKn9+Ld7rypv6hXr26uxisfvpxu91Fu3Mzdb6xk",
	"QNYl/b2FhHTz9PG6F7+onkhdtGzbi98pxnPpzc6b9/baFewc7e/tfv1QB6Ac5Y7qwLv9jXTMvW+nZP+5",
	"Tqet+VhBTYKKOuyUmYAVWbsbgjBZ5+V1+UYq8+iOio6zaztv21MueJqnliys39X5F5MpF/cgZsgEbjbw",
	"hV/KW/9qmfJGfeutpid5EHS/46xX3HHfuRtHg4NZ4f88PVo54UQU+5jvvTg/dWAdOPWx/mr1BPkECw2f",
	"b3XbZqawzTvH4wA2CZ1MV7zZy/uV9MLv2+rzyvYcI4cLWIy3fSAik2jL+5X86Q8OGqK7NaQndLZYlHEu",
	"wiSPyrbNHXZktYvWElrz85Lmd19fnhAbGtS8RFSukuL7Lj3q9VjGz93bcwPa9OYD+vr0+u8AAAD//1rO",
	"JctHMQAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
