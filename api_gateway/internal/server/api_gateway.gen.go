//go:build go1.22

// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package server

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for PermissionLevel.
const (
	Editor PermissionLevel = "editor"
	Owner  PermissionLevel = "owner"
	Viewer PermissionLevel = "viewer"
)

// Defines values for PrincipalPrincipalType.
const (
	PrincipalPrincipalTypeGuest PrincipalPrincipalType = "guest"
	PrincipalPrincipalTypeUser  PrincipalPrincipalType = "user"
)

// CreatedAt Timistamp measurred in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
type CreatedAt = int64

// Document defines model for Document.
type Document struct {
	// CreatedAt Timistamp measurred in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
	CreatedAt           CreatedAt          `json:"createdAt"`
	DocumentDescription string             `json:"documentDescription"`
	DocumentId          openapi_types.UUID `json:"documentId"`
	DocumentName        string             `json:"documentName"`

	// LastModifiedAt Timistamp measurred in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
	LastModifiedAt LastModifiedAt `json:"lastModifiedAt"`
}

// Error defines model for Error.
type Error struct {
	Message *string `json:"message,omitempty"`
}

// LastModifiedAt Timistamp measurred in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
type LastModifiedAt = int64

// Permission defines model for Permission.
type Permission struct {
	// CreatedAt Timistamp measurred in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
	CreatedAt  CreatedAt          `json:"createdAt"`
	CreatedBy  openapi_types.UUID `json:"createdBy"`
	DocumentId openapi_types.UUID `json:"documentId"`

	// LastModifiedAt Timistamp measurred in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
	LastModifiedAt  LastModifiedAt  `json:"lastModifiedAt"`
	PermissionLevel PermissionLevel `json:"permissionLevel"`
	Principal       Principal       `json:"principal"`
}

// PermissionLevel defines model for PermissionLevel.
type PermissionLevel string

// Principal defines model for Principal.
type Principal struct {
	PrincipalId   openapi_types.UUID     `json:"principalId"`
	PrincipalType PrincipalPrincipalType `json:"principalType"`
}

// PrincipalPrincipalType defines model for Principal.PrincipalType.
type PrincipalPrincipalType string

// User defines model for User.
type User struct {
	Email        string             `json:"email"`
	MaxDocuments int                `json:"maxDocuments"`
	UserId       openapi_types.UUID `json:"userId"`
	UserName     string             `json:"userName"`
}

// DocumentId defines model for DocumentId.
type DocumentId = openapi_types.UUID

// PrincipalId defines model for PrincipalId.
type PrincipalId = openapi_types.UUID

// UserId defines model for UserId.
type UserId = openapi_types.UUID

// BadRequest defines model for BadRequest.
type BadRequest = Error

// Unauthenticated defines model for Unauthenticated.
type Unauthenticated = Error

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// DeleteDocumentJSONBody defines parameters for DeleteDocument.
type DeleteDocumentJSONBody struct {
	DocumentIds []openapi_types.UUID `json:"documentIds"`
}

// GetDocumentParams defines parameters for GetDocument.
type GetDocumentParams struct {
	// Cursor a cursor can optionally be supplied for pagination
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit the number of documents to retreive in a page
	Limit *string `form:"limit,omitempty" json:"limit,omitempty"`
}

// PostDocumentJSONBody defines parameters for PostDocument.
type PostDocumentJSONBody struct {
	DocumentDescription *string            `json:"documentDescription,omitempty"`
	DocumentName        *string            `json:"documentName,omitempty"`
	UserId              openapi_types.UUID `json:"userId"`
}

// PutDocumentDocumentIdJSONBody defines parameters for PutDocumentDocumentId.
type PutDocumentDocumentIdJSONBody struct {
	DocumentDescription *string `json:"documentDescription,omitempty"`
	DocumentName        *string `json:"documentName,omitempty"`
}

// GetDocumentDocumentIdPermissionParams defines parameters for GetDocumentDocumentIdPermission.
type GetDocumentDocumentIdPermissionParams struct {
	// Cursor a cursor can optionally be supplied for pagination
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit the number of documents to retreive in a page
	Limit *string `form:"limit,omitempty" json:"limit,omitempty"`
}

// PostDocumentDocumentIdPermissionJSONBody defines parameters for PostDocumentDocumentIdPermission.
type PostDocumentDocumentIdPermissionJSONBody struct {
	UserIdToShare openapi_types.UUID `json:"userIdToShare"`
}

// PutDocumentDocumentIdPermissionPrincipalPrincipalIdJSONBody defines parameters for PutDocumentDocumentIdPermissionPrincipalPrincipalId.
type PutDocumentDocumentIdPermissionPrincipalPrincipalIdJSONBody struct {
	PermissionLevel PermissionLevel `json:"permissionLevel"`
}

// PostUserJSONBody defines parameters for PostUser.
type PostUserJSONBody struct {
	MaxDocuments *int32              `json:"maxDocuments,omitempty"`
	Password     string              `json:"password"`
	UserEmail    openapi_types.Email `json:"userEmail"`
	UserName     string              `json:"userName"`
}

// PutUserUserIdJSONBody defines parameters for PutUserUserId.
type PutUserUserIdJSONBody struct {
	NewPassword string `json:"newPassword"`
	OldPassword string `json:"oldPassword"`
}

// DeleteDocumentJSONRequestBody defines body for DeleteDocument for application/json ContentType.
type DeleteDocumentJSONRequestBody DeleteDocumentJSONBody

// PostDocumentJSONRequestBody defines body for PostDocument for application/json ContentType.
type PostDocumentJSONRequestBody PostDocumentJSONBody

// PutDocumentDocumentIdJSONRequestBody defines body for PutDocumentDocumentId for application/json ContentType.
type PutDocumentDocumentIdJSONRequestBody PutDocumentDocumentIdJSONBody

// PostDocumentDocumentIdPermissionJSONRequestBody defines body for PostDocumentDocumentIdPermission for application/json ContentType.
type PostDocumentDocumentIdPermissionJSONRequestBody PostDocumentDocumentIdPermissionJSONBody

// PutDocumentDocumentIdPermissionPrincipalPrincipalIdJSONRequestBody defines body for PutDocumentDocumentIdPermissionPrincipalPrincipalId for application/json ContentType.
type PutDocumentDocumentIdPermissionPrincipalPrincipalIdJSONRequestBody PutDocumentDocumentIdPermissionPrincipalPrincipalIdJSONBody

// PostUserJSONRequestBody defines body for PostUser for application/json ContentType.
type PostUserJSONRequestBody PostUserJSONBody

// PutUserUserIdJSONRequestBody defines body for PutUserUserId for application/json ContentType.
type PutUserUserIdJSONRequestBody PutUserUserIdJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// batch delete endpoint for deleting lists of documents
	// (DELETE /document)
	DeleteDocument(w http.ResponseWriter, r *http.Request)
	// get all the documents that a given user has owner permissions on
	// (GET /document)
	GetDocument(w http.ResponseWriter, r *http.Request, params GetDocumentParams)
	// create a new document for a user
	// (POST /document)
	PostDocument(w http.ResponseWriter, r *http.Request)
	// delete a document
	// (DELETE /document/{documentId})
	DeleteDocumentDocumentId(w http.ResponseWriter, r *http.Request, documentId DocumentId)
	// get one document
	// (GET /document/{documentId})
	GetDocumentDocumentId(w http.ResponseWriter, r *http.Request, documentId DocumentId)
	// update one document
	// (PUT /document/{documentId})
	PutDocumentDocumentId(w http.ResponseWriter, r *http.Request, documentId DocumentId)
	// get all the users that have permission on a document, this is only meant to be called by users that have owner permissions on that document
	// (GET /document/{documentId}/permission)
	GetDocumentDocumentIdPermission(w http.ResponseWriter, r *http.Request, documentId DocumentId, params GetDocumentDocumentIdPermissionParams)
	// create a permission on a document either by sharing the document with an existing user or creating a new guest user for that document
	// (POST /document/{documentId}/permission)
	PostDocumentDocumentIdPermission(w http.ResponseWriter, r *http.Request, documentId DocumentId)
	// delete a user or guests permissions on a document
	// (DELETE /document/{documentId}/permission/principal/{principalId})
	DeleteDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request, documentId DocumentId, principalId PrincipalId)
	// get the permission of a principal on a document
	// (GET /document/{documentId}/permission/principal/{principalId})
	GetDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request, documentId DocumentId, principalId PrincipalId)
	// update the permission level of a user or a guest on a document
	// (PUT /document/{documentId}/permission/principal/{principalId})
	PutDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request, documentId DocumentId, principalId PrincipalId)
	// create a user
	// (POST /user)
	PostUser(w http.ResponseWriter, r *http.Request)
	// deactivate a user
	// (DELETE /user/{userId})
	DeleteUserUserId(w http.ResponseWriter, r *http.Request, userId UserId)
	// get a user
	// (GET /user/{userId})
	GetUserUserId(w http.ResponseWriter, r *http.Request, userId UserId)
	// update a user including the users password
	// (PUT /user/{userId})
	PutUserUserId(w http.ResponseWriter, r *http.Request, userId UserId)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// DeleteDocument operation middleware
func (siw *ServerInterfaceWrapper) DeleteDocument(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDocument(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDocument operation middleware
func (siw *ServerInterfaceWrapper) GetDocument(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDocumentParams

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", r.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cursor", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDocument(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostDocument operation middleware
func (siw *ServerInterfaceWrapper) PostDocument(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDocument(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteDocumentDocumentId operation middleware
func (siw *ServerInterfaceWrapper) DeleteDocumentDocumentId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDocumentDocumentId(w, r, documentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDocumentDocumentId operation middleware
func (siw *ServerInterfaceWrapper) GetDocumentDocumentId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDocumentDocumentId(w, r, documentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PutDocumentDocumentId operation middleware
func (siw *ServerInterfaceWrapper) PutDocumentDocumentId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutDocumentDocumentId(w, r, documentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDocumentDocumentIdPermission operation middleware
func (siw *ServerInterfaceWrapper) GetDocumentDocumentIdPermission(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDocumentDocumentIdPermissionParams

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", r.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cursor", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDocumentDocumentIdPermission(w, r, documentId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostDocumentDocumentIdPermission operation middleware
func (siw *ServerInterfaceWrapper) PostDocumentDocumentIdPermission(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDocumentDocumentIdPermission(w, r, documentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteDocumentDocumentIdPermissionPrincipalPrincipalId operation middleware
func (siw *ServerInterfaceWrapper) DeleteDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	// ------------- Path parameter "principalId" -------------
	var principalId PrincipalId

	err = runtime.BindStyledParameterWithOptions("simple", "principalId", r.PathValue("principalId"), &principalId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "principalId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDocumentDocumentIdPermissionPrincipalPrincipalId(w, r, documentId, principalId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDocumentDocumentIdPermissionPrincipalPrincipalId operation middleware
func (siw *ServerInterfaceWrapper) GetDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	// ------------- Path parameter "principalId" -------------
	var principalId PrincipalId

	err = runtime.BindStyledParameterWithOptions("simple", "principalId", r.PathValue("principalId"), &principalId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "principalId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDocumentDocumentIdPermissionPrincipalPrincipalId(w, r, documentId, principalId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PutDocumentDocumentIdPermissionPrincipalPrincipalId operation middleware
func (siw *ServerInterfaceWrapper) PutDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	// ------------- Path parameter "principalId" -------------
	var principalId PrincipalId

	err = runtime.BindStyledParameterWithOptions("simple", "principalId", r.PathValue("principalId"), &principalId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "principalId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutDocumentDocumentIdPermissionPrincipalPrincipalId(w, r, documentId, principalId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostUser operation middleware
func (siw *ServerInterfaceWrapper) PostUser(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostUser(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteUserUserId operation middleware
func (siw *ServerInterfaceWrapper) DeleteUserUserId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId UserId

	err = runtime.BindStyledParameterWithOptions("simple", "userId", r.PathValue("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "userId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUserUserId(w, r, userId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetUserUserId operation middleware
func (siw *ServerInterfaceWrapper) GetUserUserId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId UserId

	err = runtime.BindStyledParameterWithOptions("simple", "userId", r.PathValue("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "userId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUserUserId(w, r, userId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PutUserUserId operation middleware
func (siw *ServerInterfaceWrapper) PutUserUserId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId UserId

	err = runtime.BindStyledParameterWithOptions("simple", "userId", r.PathValue("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "userId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutUserUserId(w, r, userId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("DELETE "+options.BaseURL+"/document", wrapper.DeleteDocument)
	m.HandleFunc("GET "+options.BaseURL+"/document", wrapper.GetDocument)
	m.HandleFunc("POST "+options.BaseURL+"/document", wrapper.PostDocument)
	m.HandleFunc("DELETE "+options.BaseURL+"/document/{documentId}", wrapper.DeleteDocumentDocumentId)
	m.HandleFunc("GET "+options.BaseURL+"/document/{documentId}", wrapper.GetDocumentDocumentId)
	m.HandleFunc("PUT "+options.BaseURL+"/document/{documentId}", wrapper.PutDocumentDocumentId)
	m.HandleFunc("GET "+options.BaseURL+"/document/{documentId}/permission", wrapper.GetDocumentDocumentIdPermission)
	m.HandleFunc("POST "+options.BaseURL+"/document/{documentId}/permission", wrapper.PostDocumentDocumentIdPermission)
	m.HandleFunc("DELETE "+options.BaseURL+"/document/{documentId}/permission/principal/{principalId}", wrapper.DeleteDocumentDocumentIdPermissionPrincipalPrincipalId)
	m.HandleFunc("GET "+options.BaseURL+"/document/{documentId}/permission/principal/{principalId}", wrapper.GetDocumentDocumentIdPermissionPrincipalPrincipalId)
	m.HandleFunc("PUT "+options.BaseURL+"/document/{documentId}/permission/principal/{principalId}", wrapper.PutDocumentDocumentIdPermissionPrincipalPrincipalId)
	m.HandleFunc("POST "+options.BaseURL+"/user", wrapper.PostUser)
	m.HandleFunc("DELETE "+options.BaseURL+"/user/{userId}", wrapper.DeleteUserUserId)
	m.HandleFunc("GET "+options.BaseURL+"/user/{userId}", wrapper.GetUserUserId)
	m.HandleFunc("PUT "+options.BaseURL+"/user/{userId}", wrapper.PutUserUserId)

	return m
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"HrwuAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
