//go:build go1.22

// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package server

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for PermissionLevel.
const (
	Editor PermissionLevel = "editor"
	Owner  PermissionLevel = "owner"
	Viewer PermissionLevel = "viewer"
)

// Defines values for PrincipalPrincipalType.
const (
	PrincipalPrincipalTypeGuest PrincipalPrincipalType = "guest"
	PrincipalPrincipalTypeUser  PrincipalPrincipalType = "user"
)

// CreatedAt Timestamp measured in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
type CreatedAt = int64

// Document defines model for Document.
type Document struct {
	// CreatedAt Timestamp measured in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
	CreatedAt           CreatedAt          `json:"createdAt"`
	DocumentDescription string             `json:"documentDescription"`
	DocumentId          openapi_types.UUID `json:"documentId"`
	DocumentName        string             `json:"documentName"`

	// LastModifiedAt Timestamp measured in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
	LastModifiedAt LastModifiedAt `json:"lastModifiedAt"`
}

// Error defines model for Error.
type Error struct {
	Message *string `json:"message,omitempty"`
}

// LastModifiedAt Timestamp measured in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
type LastModifiedAt = int64

// Permission defines model for Permission.
type Permission struct {
	// CreatedAt Timestamp measured in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
	CreatedAt  CreatedAt          `json:"createdAt"`
	CreatedBy  openapi_types.UUID `json:"createdBy"`
	DocumentId openapi_types.UUID `json:"documentId"`

	// LastModifiedAt Timestamp measured in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
	LastModifiedAt  LastModifiedAt  `json:"lastModifiedAt"`
	PermissionLevel PermissionLevel `json:"permissionLevel"`
	Principal       Principal       `json:"principal"`
}

// PermissionLevel defines model for PermissionLevel.
type PermissionLevel string

// Principal defines model for Principal.
type Principal struct {
	PrincipalId   openapi_types.UUID     `json:"principalId"`
	PrincipalType PrincipalPrincipalType `json:"principalType"`
}

// PrincipalPrincipalType defines model for Principal.PrincipalType.
type PrincipalPrincipalType string

// User defines model for User.
type User struct {
	Email        string             `json:"email"`
	MaxDocuments int32              `json:"maxDocuments"`
	UserId       openapi_types.UUID `json:"userId"`
	UserName     string             `json:"userName"`
}

// DocumentId defines model for DocumentId.
type DocumentId = openapi_types.UUID

// PrincipalId defines model for PrincipalId.
type PrincipalId = openapi_types.UUID

// UserId defines model for UserId.
type UserId = openapi_types.UUID

// BadRequest defines model for BadRequest.
type BadRequest = Error

// GetDocumentResponse defines model for GetDocumentResponse.
type GetDocumentResponse struct {
	Cursor    *string    `json:"cursor,omitempty"`
	Documents []Document `json:"documents"`
}

// LoginResponse defines model for LoginResponse.
type LoginResponse struct {
	ExpiresIn int32  `json:"expiresIn"`
	Token     string `json:"token"`
}

// Unauthenticated defines model for Unauthenticated.
type Unauthenticated = Error

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// PostAuthLoginJSONBody defines parameters for PostAuthLogin.
type PostAuthLoginJSONBody struct {
	Password string `json:"password"`
	UserName string `json:"userName"`
}

// DeleteDocumentJSONBody defines parameters for DeleteDocument.
type DeleteDocumentJSONBody struct {
	DocumentIds []openapi_types.UUID `json:"documentIds"`
}

// GetDocumentParams defines parameters for GetDocument.
type GetDocumentParams struct {
	// Cursor a cursor can optionally be supplied for pagination
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit the number of documents to retrieve in a page
	Limit           *string          `form:"limit,omitempty" json:"limit,omitempty"`
	PermissionLevel *PermissionLevel `form:"permissionLevel,omitempty" json:"permissionLevel,omitempty"`
}

// PostDocumentJSONBody defines parameters for PostDocument.
type PostDocumentJSONBody struct {
	DocumentDescription *string            `json:"documentDescription,omitempty"`
	DocumentName        *string            `json:"documentName,omitempty"`
	UserId              openapi_types.UUID `json:"userId"`
}

// PutDocumentDocumentIdJSONBody defines parameters for PutDocumentDocumentId.
type PutDocumentDocumentIdJSONBody struct {
	DocumentDescription *string `json:"documentDescription,omitempty"`
	DocumentName        *string `json:"documentName,omitempty"`
}

// GetDocumentDocumentIdPermissionParams defines parameters for GetDocumentDocumentIdPermission.
type GetDocumentDocumentIdPermissionParams struct {
	// Cursor a cursor can optionally be supplied for pagination
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit the number of documents to retrieve in a page
	Limit *string `form:"limit,omitempty" json:"limit,omitempty"`
}

// PostDocumentDocumentIdPermissionJSONBody defines parameters for PostDocumentDocumentIdPermission.
type PostDocumentDocumentIdPermissionJSONBody struct {
	UserIdToShare openapi_types.UUID `json:"userIdToShare"`
}

// PutDocumentDocumentIdPermissionPrincipalPrincipalIdJSONBody defines parameters for PutDocumentDocumentIdPermissionPrincipalPrincipalId.
type PutDocumentDocumentIdPermissionPrincipalPrincipalIdJSONBody struct {
	PermissionLevel PermissionLevel `json:"permissionLevel"`
}

// PostUserJSONBody defines parameters for PostUser.
type PostUserJSONBody struct {
	MaxDocuments *int32              `json:"maxDocuments,omitempty"`
	Password     string              `json:"password"`
	UserEmail    openapi_types.Email `json:"userEmail"`
	UserName     string              `json:"userName"`
}

// PutUserUserIdJSONBody defines parameters for PutUserUserId.
type PutUserUserIdJSONBody struct {
	NewPassword string `json:"newPassword"`
	OldPassword string `json:"oldPassword"`
}

// PostAuthLoginJSONRequestBody defines body for PostAuthLogin for application/json ContentType.
type PostAuthLoginJSONRequestBody PostAuthLoginJSONBody

// DeleteDocumentJSONRequestBody defines body for DeleteDocument for application/json ContentType.
type DeleteDocumentJSONRequestBody DeleteDocumentJSONBody

// PostDocumentJSONRequestBody defines body for PostDocument for application/json ContentType.
type PostDocumentJSONRequestBody PostDocumentJSONBody

// PutDocumentDocumentIdJSONRequestBody defines body for PutDocumentDocumentId for application/json ContentType.
type PutDocumentDocumentIdJSONRequestBody PutDocumentDocumentIdJSONBody

// PostDocumentDocumentIdPermissionJSONRequestBody defines body for PostDocumentDocumentIdPermission for application/json ContentType.
type PostDocumentDocumentIdPermissionJSONRequestBody PostDocumentDocumentIdPermissionJSONBody

// PutDocumentDocumentIdPermissionPrincipalPrincipalIdJSONRequestBody defines body for PutDocumentDocumentIdPermissionPrincipalPrincipalId for application/json ContentType.
type PutDocumentDocumentIdPermissionPrincipalPrincipalIdJSONRequestBody PutDocumentDocumentIdPermissionPrincipalPrincipalIdJSONBody

// PostUserJSONRequestBody defines body for PostUser for application/json ContentType.
type PostUserJSONRequestBody PostUserJSONBody

// PutUserUserIdJSONRequestBody defines body for PutUserUserId for application/json ContentType.
type PutUserUserIdJSONRequestBody PutUserUserIdJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// get a token
	// (POST /auth/login)
	PostAuthLogin(w http.ResponseWriter, r *http.Request)
	// batch delete endpoint for deleting lists of documents
	// (DELETE /document)
	DeleteDocument(w http.ResponseWriter, r *http.Request)
	// get all the documents that a given user has the given permission on
	// (GET /document)
	GetDocument(w http.ResponseWriter, r *http.Request, params GetDocumentParams)
	// create a new document for a user
	// (POST /document)
	PostDocument(w http.ResponseWriter, r *http.Request)
	// delete a document
	// (DELETE /document/{documentId})
	DeleteDocumentDocumentId(w http.ResponseWriter, r *http.Request, documentId DocumentId)
	// get one document
	// (GET /document/{documentId})
	GetDocumentDocumentId(w http.ResponseWriter, r *http.Request, documentId DocumentId)
	// update one document
	// (PUT /document/{documentId})
	PutDocumentDocumentId(w http.ResponseWriter, r *http.Request, documentId DocumentId)
	// get all the users that have permission on a document, this is only meant to be called by users that have owner permissions on that document
	// (GET /document/{documentId}/permission)
	GetDocumentDocumentIdPermission(w http.ResponseWriter, r *http.Request, documentId DocumentId, params GetDocumentDocumentIdPermissionParams)
	// create a permission on a document either by sharing the document with an existing user or creating a new guest user for that document
	// (POST /document/{documentId}/permission)
	PostDocumentDocumentIdPermission(w http.ResponseWriter, r *http.Request, documentId DocumentId)
	// delete a user or guests permissions on a document
	// (DELETE /document/{documentId}/permission/principal/{principalId})
	DeleteDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request, documentId DocumentId, principalId PrincipalId)
	// get the permission of a principal on a document
	// (GET /document/{documentId}/permission/principal/{principalId})
	GetDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request, documentId DocumentId, principalId PrincipalId)
	// update the permission level of a user or a guest on a document
	// (PUT /document/{documentId}/permission/principal/{principalId})
	PutDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request, documentId DocumentId, principalId PrincipalId)
	// create a user
	// (POST /user)
	PostUser(w http.ResponseWriter, r *http.Request)
	// deactivate a user
	// (DELETE /user/{userId})
	DeleteUserUserId(w http.ResponseWriter, r *http.Request, userId UserId)
	// get a user
	// (GET /user/{userId})
	GetUserUserId(w http.ResponseWriter, r *http.Request, userId UserId)
	// update a user including the users password
	// (PUT /user/{userId})
	PutUserUserId(w http.ResponseWriter, r *http.Request, userId UserId)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// PostAuthLogin operation middleware
func (siw *ServerInterfaceWrapper) PostAuthLogin(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuthLogin(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteDocument operation middleware
func (siw *ServerInterfaceWrapper) DeleteDocument(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDocument(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDocument operation middleware
func (siw *ServerInterfaceWrapper) GetDocument(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDocumentParams

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", r.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cursor", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "permissionLevel" -------------

	err = runtime.BindQueryParameter("form", true, false, "permissionLevel", r.URL.Query(), &params.PermissionLevel)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "permissionLevel", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDocument(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostDocument operation middleware
func (siw *ServerInterfaceWrapper) PostDocument(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDocument(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteDocumentDocumentId operation middleware
func (siw *ServerInterfaceWrapper) DeleteDocumentDocumentId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDocumentDocumentId(w, r, documentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDocumentDocumentId operation middleware
func (siw *ServerInterfaceWrapper) GetDocumentDocumentId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDocumentDocumentId(w, r, documentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PutDocumentDocumentId operation middleware
func (siw *ServerInterfaceWrapper) PutDocumentDocumentId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutDocumentDocumentId(w, r, documentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDocumentDocumentIdPermission operation middleware
func (siw *ServerInterfaceWrapper) GetDocumentDocumentIdPermission(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDocumentDocumentIdPermissionParams

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", r.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cursor", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDocumentDocumentIdPermission(w, r, documentId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostDocumentDocumentIdPermission operation middleware
func (siw *ServerInterfaceWrapper) PostDocumentDocumentIdPermission(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDocumentDocumentIdPermission(w, r, documentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteDocumentDocumentIdPermissionPrincipalPrincipalId operation middleware
func (siw *ServerInterfaceWrapper) DeleteDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	// ------------- Path parameter "principalId" -------------
	var principalId PrincipalId

	err = runtime.BindStyledParameterWithOptions("simple", "principalId", r.PathValue("principalId"), &principalId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "principalId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDocumentDocumentIdPermissionPrincipalPrincipalId(w, r, documentId, principalId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDocumentDocumentIdPermissionPrincipalPrincipalId operation middleware
func (siw *ServerInterfaceWrapper) GetDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	// ------------- Path parameter "principalId" -------------
	var principalId PrincipalId

	err = runtime.BindStyledParameterWithOptions("simple", "principalId", r.PathValue("principalId"), &principalId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "principalId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDocumentDocumentIdPermissionPrincipalPrincipalId(w, r, documentId, principalId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PutDocumentDocumentIdPermissionPrincipalPrincipalId operation middleware
func (siw *ServerInterfaceWrapper) PutDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	// ------------- Path parameter "principalId" -------------
	var principalId PrincipalId

	err = runtime.BindStyledParameterWithOptions("simple", "principalId", r.PathValue("principalId"), &principalId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "principalId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutDocumentDocumentIdPermissionPrincipalPrincipalId(w, r, documentId, principalId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostUser operation middleware
func (siw *ServerInterfaceWrapper) PostUser(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostUser(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteUserUserId operation middleware
func (siw *ServerInterfaceWrapper) DeleteUserUserId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId UserId

	err = runtime.BindStyledParameterWithOptions("simple", "userId", r.PathValue("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "userId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUserUserId(w, r, userId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetUserUserId operation middleware
func (siw *ServerInterfaceWrapper) GetUserUserId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId UserId

	err = runtime.BindStyledParameterWithOptions("simple", "userId", r.PathValue("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "userId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUserUserId(w, r, userId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PutUserUserId operation middleware
func (siw *ServerInterfaceWrapper) PutUserUserId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId UserId

	err = runtime.BindStyledParameterWithOptions("simple", "userId", r.PathValue("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "userId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutUserUserId(w, r, userId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("POST "+options.BaseURL+"/auth/login", wrapper.PostAuthLogin)
	m.HandleFunc("DELETE "+options.BaseURL+"/document", wrapper.DeleteDocument)
	m.HandleFunc("GET "+options.BaseURL+"/document", wrapper.GetDocument)
	m.HandleFunc("POST "+options.BaseURL+"/document", wrapper.PostDocument)
	m.HandleFunc("DELETE "+options.BaseURL+"/document/{documentId}", wrapper.DeleteDocumentDocumentId)
	m.HandleFunc("GET "+options.BaseURL+"/document/{documentId}", wrapper.GetDocumentDocumentId)
	m.HandleFunc("PUT "+options.BaseURL+"/document/{documentId}", wrapper.PutDocumentDocumentId)
	m.HandleFunc("GET "+options.BaseURL+"/document/{documentId}/permission", wrapper.GetDocumentDocumentIdPermission)
	m.HandleFunc("POST "+options.BaseURL+"/document/{documentId}/permission", wrapper.PostDocumentDocumentIdPermission)
	m.HandleFunc("DELETE "+options.BaseURL+"/document/{documentId}/permission/principal/{principalId}", wrapper.DeleteDocumentDocumentIdPermissionPrincipalPrincipalId)
	m.HandleFunc("GET "+options.BaseURL+"/document/{documentId}/permission/principal/{principalId}", wrapper.GetDocumentDocumentIdPermissionPrincipalPrincipalId)
	m.HandleFunc("PUT "+options.BaseURL+"/document/{documentId}/permission/principal/{principalId}", wrapper.PutDocumentDocumentIdPermissionPrincipalPrincipalId)
	m.HandleFunc("POST "+options.BaseURL+"/user", wrapper.PostUser)
	m.HandleFunc("DELETE "+options.BaseURL+"/user/{userId}", wrapper.DeleteUserUserId)
	m.HandleFunc("GET "+options.BaseURL+"/user/{userId}", wrapper.GetUserUserId)
	m.HandleFunc("PUT "+options.BaseURL+"/user/{userId}", wrapper.PutUserUserId)

	return m
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xaX3PbuBH/Khi0D+0MY0m2zsnpLYmvV7duqrnY04eMHyByJSJHAgwASlY9+u6dBfgH",
	"FCmTtnU3jdpMHkwSWGAXv9397UKPNJRpJgUIo+nskWZMsRQMKPt0JcM8BWGuI3yCB5ZmCdAZnZxfwPSH",
	"y7dv4N2PizeT8+jiDZv+cPlmen55OZlO3k7H4zENKBd0RjNmYhpQwVKcGdUSA6rgW84VRHRmVA4B1WEM",
	"KcOlllKlzNAZzXOOI802w9naKC5WdLcL6FxxEfKMJcfbW+aJfN3m7jSo4+0rd9Jes6UdTtaZFBrswX5g",
	"0S/wLQdt8CmUwoCwf7IsS3jIDJdi9FVLge/qZf6oYEln9A+jGjQj91WPflJKKrdUBDpUPEMhdIZrkXKx",
	"XUB/BlPC6pdiS8/aQ6ZkBspwp0iYKy0V/rWnclBBzY7jBlLdp0K5L5xdiGNKsS119iuN/8UTfV+NlIuv",
	"EJouA/zz7yjwRq64OILG8JBxBfpaNM6dC3NxXh88FwZWoKwi8lcQHQbaU8kNCzzxQ1T7nIchaL3ME2L1",
	"wwXvBMtNDMKgRhANULVykkeagtZsZS1fC+FSkJRrzcWKSEW4WLOER7jWK6H5vrlGZY9KC6n4v1+ugom5",
	"Jui9hGsipCEsSeQGImIkyUDh4RE7hoV2Q69X6JM05L1bxJ5wMQHlfVSAx/HeqtCcdctT0IalGUmB6VxB",
	"RDhaPEm4hlCKSBPNRQjkTvAHApkMY/KnvzGRM7Ulk4BMfnw7Dsh4PLP/yd3txz9bJBUmmbwdn0/fXZyP",
	"8V/QwOzltBOzlSO2/d3X4ikT1ep6oeDKV/uJkOFid09QrYd/snG6Q17CtPmHjPiSD9nyTXP0oaBjU0Fj",
	"6W4FA89Yra20nTugDlUtk1d47gohLSE3LZX/y7E2B2Vji4PEMdBWzPqwfRaIBmLudZAKaFapewNrSPoE",
	"zPeGo4SSJvXOrQbuQ7kWETRhvb8735jPxvO8rSqIPMUNrDlsQCFwIm4k/iE3ApQnprb43Ne3iY+sSUJ7",
	"D68af2u/1PvBJEEDurIk6T7oydVNotoU2mUIpKMdRCJlPOkMWyl7uPLJ0wCWkVeMt9cIOPRAxNzTsyK+",
	"1ZSg2PXeHjuoSkA1hLniZvsZ4ehUXgBToDDr109/Kff7dYO4suBFSe5rrUBsTOZSLhdL2RHYbCLPONEZ",
	"hCSCJRegiYmBoJnUkoVAFmA2AMK+xaErZmDDtoSJyL4LEw7CnJHbGMj7+TX5ufjOnaAsXyQ8JCCM2maS",
	"C0OWUtkva6a4zDVZsPBXEBFJeaikBrXmIegzcm2IVGEM2ihmQFuiA9poJCJpnhieJdCcY7eUKbnmET6Q",
	"UMag+dpXplzbbRpF5RpPyHBjCx5fgb/e3s4r4/BlwZ5oQNegXOil47PJ2RjxITMQLON0Ri/OxmcXiHBm",
	"Ynt+I+Rko8QyTcSzdPULotoKRATSudQGj9gRUoco0OaDjLavoN0Z03ojlYV4yh5uQKwQRZfTgKZclI/v",
	"evDuzbw4b8y8CAY4Q+ED1V66KPp+qXc+Hh8K1NW4UbM42QV0OmSWV0XaKZP+KfvFge+odPblPqA6T1Om",
	"tnRGV2AII2VhYthKox2s997jvFHk0cQIEjDQRsOVfV8RymPBoc5azfKyN/oNqitR6pDyC92vnEN4hFGC",
	"Gd8pN0wYTZxt2h2ENlSm7bj2SZKPhY1+T1zgvIuh84oyzYKpgs+CmTAudCcgojpi2ndYTCYcg6Bckrqg",
	"r4HmpZddgGBsg8vrZVi3rHtnX/bNyIhrVZCQCSLtW5YkW7IAonMEHkR2bxlbcVFGR9sM+paD2tbdoKLj",
	"4ZeKrcDx2IETkacLUA1lMWYrMIqDDeyE4epwYN2Ep9z0Lds1sc3phhW5Leq5u+8ObSffOvqOnM7G7CQh",
	"fmQqwhIjK74G4RoiMXOUxr2qIUKkOOiCh9P9bxbehzYMDnYABvPibuo7LMEPOOquruv3hSxX/BFGBGzq",
	"pIchk5GifOqCjc8TRo91gt0NJw1XzTuLvoT53flskSJZZdUXJ8GnLDU+2k1DHWtPJGBKAf2232MXXQvW",
	"Q0beSWDazPKuyJkfOriXhdCUi7kXRSfBbxNUdwOJccaUI3cNltzNkI0kYcyEJT8v4MjfHeryLMJgOgB4",
	"B+PnKGs0ToeHBq/h+n/OfN+dzI9PaevTGk5qvZPqo7W++JMntkg3ClIbszU06auXRwN3u8c1kSLZkhSY",
	"65MtgIQsSSAii21LmG1EeyJxsvvc4alz3+yvThK9/PqAEx+HczvKeys/x0zBSxlzOf0ZnbGj5TfbvX9G",
	"E/w6snuN/sVdP7pf39Nzq4rVH/IhAtzEoNBTdMzQEs18vuEmJkwQeODa9nRseYk5AyXjC1cx2MNxH13j",
	"eohDDUl+o+r+ZfToXcy8qL6oV68uneZ7P0o63eqjPLiVu5rYi4BsSPh7CQkZZunjVS9+Uj2RvGjZtue/",
	"S/Tn0pqDD+/luSvoHe2f7fPqoQFAOcr10iuv5Q/SMfe9m5L9fpVOV/Gxh5oEN+qwU0YCVkTtYQjCYJ2X",
	"N90HqcydaxUd59R6L8pTLniap5YstC/NG3eK/ZeIP5UX9tUy5WX403eOteTJMy4Z6xV7Lhz7cTR5NSv8",
	"n6dHex1ORLGP+dGjs9MA1oFT7+pfFJ8gn2Ch4esnzXaYKTxlneNxABuETqYqPmzl56X0wu5P5ee94zlG",
	"DBewmXtxuBVKZRI98X0vfvqDg4boYQXpCfUWizTORZjkUVm2uWZHVpuoFdCavwdp/mTryz1iQ4Nal4jK",
	"VVL8NEvPRiOW8TP39cyANqP1hO7ud/8JAAD//8bMB1LjMgAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
