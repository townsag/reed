//go:build go1.22

// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package server

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for PermissionLevel.
const (
	Editor PermissionLevel = "editor"
	Owner  PermissionLevel = "owner"
	Viewer PermissionLevel = "viewer"
)

// Defines values for PrincipalPrincipalType.
const (
	PrincipalPrincipalTypeGuest PrincipalPrincipalType = "guest"
	PrincipalPrincipalTypeUser  PrincipalPrincipalType = "user"
)

// CreatedAt Timestamp measured in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
type CreatedAt = int64

// Document defines model for Document.
type Document struct {
	// CreatedAt Timestamp measured in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
	CreatedAt           CreatedAt          `json:"createdAt"`
	DocumentDescription *string            `json:"documentDescription,omitempty"`
	DocumentId          openapi_types.UUID `json:"documentId"`
	DocumentName        *string            `json:"documentName,omitempty"`

	// LastModifiedAt Timestamp measured in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
	LastModifiedAt LastModifiedAt `json:"lastModifiedAt"`
}

// Error defines model for Error.
type Error struct {
	Message *string `json:"message,omitempty"`
}

// LastModifiedAt Timestamp measured in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
type LastModifiedAt = int64

// Permission defines model for Permission.
type Permission struct {
	// CreatedAt Timestamp measured in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
	CreatedAt  CreatedAt          `json:"createdAt"`
	CreatedBy  openapi_types.UUID `json:"createdBy"`
	DocumentId openapi_types.UUID `json:"documentId"`

	// LastModifiedAt Timestamp measured in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
	LastModifiedAt  LastModifiedAt  `json:"lastModifiedAt"`
	PermissionLevel PermissionLevel `json:"permissionLevel"`
	Principal       Principal       `json:"principal"`
}

// PermissionLevel defines model for PermissionLevel.
type PermissionLevel string

// Principal defines model for Principal.
type Principal struct {
	PrincipalId   openapi_types.UUID     `json:"principalId"`
	PrincipalType PrincipalPrincipalType `json:"principalType"`
}

// PrincipalPrincipalType defines model for Principal.PrincipalType.
type PrincipalPrincipalType string

// User defines model for User.
type User struct {
	Email        string             `json:"email"`
	MaxDocuments int32              `json:"maxDocuments"`
	UserId       openapi_types.UUID `json:"userId"`
	UserName     string             `json:"userName"`
}

// DocumentId defines model for DocumentId.
type DocumentId = openapi_types.UUID

// PrincipalId defines model for PrincipalId.
type PrincipalId = openapi_types.UUID

// UserId defines model for UserId.
type UserId = openapi_types.UUID

// BadRequest defines model for BadRequest.
type BadRequest = Error

// GetDocumentResponse defines model for GetDocumentResponse.
type GetDocumentResponse struct {
	Cursor    *string    `json:"cursor,omitempty"`
	Documents []Document `json:"documents"`
}

// LoginResponse defines model for LoginResponse.
type LoginResponse struct {
	ExpiresIn int32  `json:"expiresIn"`
	Token     string `json:"token"`
}

// PostDocumentResponse defines model for PostDocumentResponse.
type PostDocumentResponse struct {
	DocumentId openapi_types.UUID `json:"documentId"`
}

// Unauthenticated defines model for Unauthenticated.
type Unauthenticated = Error

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// PostAuthLoginJSONBody defines parameters for PostAuthLogin.
type PostAuthLoginJSONBody struct {
	Password string `json:"password"`
	UserName string `json:"userName"`
}

// DeleteDocumentJSONBody defines parameters for DeleteDocument.
type DeleteDocumentJSONBody struct {
	DocumentIds []openapi_types.UUID `json:"documentIds"`
}

// GetDocumentParams defines parameters for GetDocument.
type GetDocumentParams struct {
	// Cursor a cursor can optionally be supplied for pagination
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit the number of documents to retrieve in a page
	Limit           *int32           `form:"limit,omitempty" json:"limit,omitempty"`
	PermissionLevel *PermissionLevel `form:"permissionLevel,omitempty" json:"permissionLevel,omitempty"`
}

// PostDocumentJSONBody defines parameters for PostDocument.
type PostDocumentJSONBody struct {
	DocumentDescription *string            `json:"documentDescription,omitempty"`
	DocumentName        *string            `json:"documentName,omitempty"`
	UserId              openapi_types.UUID `json:"userId"`
}

// PutDocumentDocumentIdJSONBody defines parameters for PutDocumentDocumentId.
type PutDocumentDocumentIdJSONBody struct {
	DocumentDescription *string `json:"documentDescription,omitempty"`
	DocumentName        *string `json:"documentName,omitempty"`
}

// GetDocumentDocumentIdPermissionParams defines parameters for GetDocumentDocumentIdPermission.
type GetDocumentDocumentIdPermissionParams struct {
	// Cursor a cursor can optionally be supplied for pagination
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit the number of documents to retrieve in a page
	Limit *string `form:"limit,omitempty" json:"limit,omitempty"`

	// PermissionFilter specify how the retrieved users can be filtered by permission level
	PermissionFilter *[]PermissionLevel `form:"permissionFilter,omitempty" json:"permissionFilter,omitempty"`
}

// PostDocumentDocumentIdPermissionJSONBody defines parameters for PostDocumentDocumentIdPermission.
type PostDocumentDocumentIdPermissionJSONBody struct {
	UserIdToShare openapi_types.UUID `json:"userIdToShare"`
}

// PutDocumentDocumentIdPermissionPrincipalPrincipalIdJSONBody defines parameters for PutDocumentDocumentIdPermissionPrincipalPrincipalId.
type PutDocumentDocumentIdPermissionPrincipalPrincipalIdJSONBody struct {
	PermissionLevel PermissionLevel `json:"permissionLevel"`
}

// PostUserJSONBody defines parameters for PostUser.
type PostUserJSONBody struct {
	MaxDocuments *int32              `json:"maxDocuments,omitempty"`
	Password     string              `json:"password"`
	UserEmail    openapi_types.Email `json:"userEmail"`
	UserName     string              `json:"userName"`
}

// PutUserUserIdJSONBody defines parameters for PutUserUserId.
type PutUserUserIdJSONBody struct {
	NewPassword string `json:"newPassword"`
	OldPassword string `json:"oldPassword"`
}

// PostAuthLoginJSONRequestBody defines body for PostAuthLogin for application/json ContentType.
type PostAuthLoginJSONRequestBody PostAuthLoginJSONBody

// DeleteDocumentJSONRequestBody defines body for DeleteDocument for application/json ContentType.
type DeleteDocumentJSONRequestBody DeleteDocumentJSONBody

// PostDocumentJSONRequestBody defines body for PostDocument for application/json ContentType.
type PostDocumentJSONRequestBody PostDocumentJSONBody

// PutDocumentDocumentIdJSONRequestBody defines body for PutDocumentDocumentId for application/json ContentType.
type PutDocumentDocumentIdJSONRequestBody PutDocumentDocumentIdJSONBody

// PostDocumentDocumentIdPermissionJSONRequestBody defines body for PostDocumentDocumentIdPermission for application/json ContentType.
type PostDocumentDocumentIdPermissionJSONRequestBody PostDocumentDocumentIdPermissionJSONBody

// PutDocumentDocumentIdPermissionPrincipalPrincipalIdJSONRequestBody defines body for PutDocumentDocumentIdPermissionPrincipalPrincipalId for application/json ContentType.
type PutDocumentDocumentIdPermissionPrincipalPrincipalIdJSONRequestBody PutDocumentDocumentIdPermissionPrincipalPrincipalIdJSONBody

// PostUserJSONRequestBody defines body for PostUser for application/json ContentType.
type PostUserJSONRequestBody PostUserJSONBody

// PutUserUserIdJSONRequestBody defines body for PutUserUserId for application/json ContentType.
type PutUserUserIdJSONRequestBody PutUserUserIdJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// get a token
	// (POST /auth/login)
	PostAuthLogin(w http.ResponseWriter, r *http.Request)
	// batch delete endpoint for deleting lists of documents
	// (DELETE /document)
	DeleteDocument(w http.ResponseWriter, r *http.Request)
	// get all the documents that a given user has the given permission on
	// (GET /document)
	GetDocument(w http.ResponseWriter, r *http.Request, params GetDocumentParams)
	// create a new document for a user
	// (POST /document)
	PostDocument(w http.ResponseWriter, r *http.Request)
	// delete a document
	// (DELETE /document/{documentId})
	DeleteDocumentDocumentId(w http.ResponseWriter, r *http.Request, documentId DocumentId)
	// get one document
	// (GET /document/{documentId})
	GetDocumentDocumentId(w http.ResponseWriter, r *http.Request, documentId DocumentId)
	// update one document
	// (PUT /document/{documentId})
	PutDocumentDocumentId(w http.ResponseWriter, r *http.Request, documentId DocumentId)
	// get all the users that have permission on a document, this is only meant to be called by users that have owner permissions on that document
	// (GET /document/{documentId}/permission)
	GetDocumentDocumentIdPermission(w http.ResponseWriter, r *http.Request, documentId DocumentId, params GetDocumentDocumentIdPermissionParams)
	// create a permission on a document either by sharing the document with an existing user or creating a new guest user for that document
	// (POST /document/{documentId}/permission)
	PostDocumentDocumentIdPermission(w http.ResponseWriter, r *http.Request, documentId DocumentId)
	// delete a user or guests permissions on a document
	// (DELETE /document/{documentId}/permission/principal/{principalId})
	DeleteDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request, documentId DocumentId, principalId PrincipalId)
	// get the permission of a principal on a document
	// (GET /document/{documentId}/permission/principal/{principalId})
	GetDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request, documentId DocumentId, principalId PrincipalId)
	// update the permission level of a user or a guest on a document
	// (PUT /document/{documentId}/permission/principal/{principalId})
	PutDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request, documentId DocumentId, principalId PrincipalId)
	// create a user
	// (POST /user)
	PostUser(w http.ResponseWriter, r *http.Request)
	// deactivate a user
	// (DELETE /user/{userId})
	DeleteUserUserId(w http.ResponseWriter, r *http.Request, userId UserId)
	// get a user
	// (GET /user/{userId})
	GetUserUserId(w http.ResponseWriter, r *http.Request, userId UserId)
	// update a user including the users password
	// (PUT /user/{userId})
	PutUserUserId(w http.ResponseWriter, r *http.Request, userId UserId)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// PostAuthLogin operation middleware
func (siw *ServerInterfaceWrapper) PostAuthLogin(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuthLogin(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteDocument operation middleware
func (siw *ServerInterfaceWrapper) DeleteDocument(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDocument(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDocument operation middleware
func (siw *ServerInterfaceWrapper) GetDocument(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDocumentParams

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", r.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cursor", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "permissionLevel" -------------

	err = runtime.BindQueryParameter("form", true, false, "permissionLevel", r.URL.Query(), &params.PermissionLevel)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "permissionLevel", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDocument(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostDocument operation middleware
func (siw *ServerInterfaceWrapper) PostDocument(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDocument(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteDocumentDocumentId operation middleware
func (siw *ServerInterfaceWrapper) DeleteDocumentDocumentId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDocumentDocumentId(w, r, documentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDocumentDocumentId operation middleware
func (siw *ServerInterfaceWrapper) GetDocumentDocumentId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDocumentDocumentId(w, r, documentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PutDocumentDocumentId operation middleware
func (siw *ServerInterfaceWrapper) PutDocumentDocumentId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutDocumentDocumentId(w, r, documentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDocumentDocumentIdPermission operation middleware
func (siw *ServerInterfaceWrapper) GetDocumentDocumentIdPermission(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDocumentDocumentIdPermissionParams

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", r.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cursor", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "permissionFilter" -------------

	err = runtime.BindQueryParameter("form", true, false, "permissionFilter", r.URL.Query(), &params.PermissionFilter)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "permissionFilter", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDocumentDocumentIdPermission(w, r, documentId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostDocumentDocumentIdPermission operation middleware
func (siw *ServerInterfaceWrapper) PostDocumentDocumentIdPermission(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDocumentDocumentIdPermission(w, r, documentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteDocumentDocumentIdPermissionPrincipalPrincipalId operation middleware
func (siw *ServerInterfaceWrapper) DeleteDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	// ------------- Path parameter "principalId" -------------
	var principalId PrincipalId

	err = runtime.BindStyledParameterWithOptions("simple", "principalId", r.PathValue("principalId"), &principalId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "principalId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDocumentDocumentIdPermissionPrincipalPrincipalId(w, r, documentId, principalId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDocumentDocumentIdPermissionPrincipalPrincipalId operation middleware
func (siw *ServerInterfaceWrapper) GetDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	// ------------- Path parameter "principalId" -------------
	var principalId PrincipalId

	err = runtime.BindStyledParameterWithOptions("simple", "principalId", r.PathValue("principalId"), &principalId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "principalId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDocumentDocumentIdPermissionPrincipalPrincipalId(w, r, documentId, principalId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PutDocumentDocumentIdPermissionPrincipalPrincipalId operation middleware
func (siw *ServerInterfaceWrapper) PutDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	// ------------- Path parameter "principalId" -------------
	var principalId PrincipalId

	err = runtime.BindStyledParameterWithOptions("simple", "principalId", r.PathValue("principalId"), &principalId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "principalId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutDocumentDocumentIdPermissionPrincipalPrincipalId(w, r, documentId, principalId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostUser operation middleware
func (siw *ServerInterfaceWrapper) PostUser(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostUser(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteUserUserId operation middleware
func (siw *ServerInterfaceWrapper) DeleteUserUserId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId UserId

	err = runtime.BindStyledParameterWithOptions("simple", "userId", r.PathValue("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "userId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUserUserId(w, r, userId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetUserUserId operation middleware
func (siw *ServerInterfaceWrapper) GetUserUserId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId UserId

	err = runtime.BindStyledParameterWithOptions("simple", "userId", r.PathValue("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "userId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUserUserId(w, r, userId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PutUserUserId operation middleware
func (siw *ServerInterfaceWrapper) PutUserUserId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId UserId

	err = runtime.BindStyledParameterWithOptions("simple", "userId", r.PathValue("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "userId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutUserUserId(w, r, userId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("POST "+options.BaseURL+"/auth/login", wrapper.PostAuthLogin)
	m.HandleFunc("DELETE "+options.BaseURL+"/document", wrapper.DeleteDocument)
	m.HandleFunc("GET "+options.BaseURL+"/document", wrapper.GetDocument)
	m.HandleFunc("POST "+options.BaseURL+"/document", wrapper.PostDocument)
	m.HandleFunc("DELETE "+options.BaseURL+"/document/{documentId}", wrapper.DeleteDocumentDocumentId)
	m.HandleFunc("GET "+options.BaseURL+"/document/{documentId}", wrapper.GetDocumentDocumentId)
	m.HandleFunc("PUT "+options.BaseURL+"/document/{documentId}", wrapper.PutDocumentDocumentId)
	m.HandleFunc("GET "+options.BaseURL+"/document/{documentId}/permission", wrapper.GetDocumentDocumentIdPermission)
	m.HandleFunc("POST "+options.BaseURL+"/document/{documentId}/permission", wrapper.PostDocumentDocumentIdPermission)
	m.HandleFunc("DELETE "+options.BaseURL+"/document/{documentId}/permission/principal/{principalId}", wrapper.DeleteDocumentDocumentIdPermissionPrincipalPrincipalId)
	m.HandleFunc("GET "+options.BaseURL+"/document/{documentId}/permission/principal/{principalId}", wrapper.GetDocumentDocumentIdPermissionPrincipalPrincipalId)
	m.HandleFunc("PUT "+options.BaseURL+"/document/{documentId}/permission/principal/{principalId}", wrapper.PutDocumentDocumentIdPermissionPrincipalPrincipalId)
	m.HandleFunc("POST "+options.BaseURL+"/user", wrapper.PostUser)
	m.HandleFunc("DELETE "+options.BaseURL+"/user/{userId}", wrapper.DeleteUserUserId)
	m.HandleFunc("GET "+options.BaseURL+"/user/{userId}", wrapper.GetUserUserId)
	m.HandleFunc("PUT "+options.BaseURL+"/user/{userId}", wrapper.PutUserUserId)

	return m
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+RaX3PbuBH/Khi0D+0MY0m2zsnpLYnvrm7dVHOxpw8ZP0DkSkSOBBgAlKx69N07C/AP",
	"KFEiLSs3Z18mDxYJLLCL3+7+dsFHGso0kwKE0XTySDOmWAoGlP11JcM8BWGuI/wFDyzNEqATOjq/gPEP",
	"l2/fwLsfZ29G59HFGzb+4fLN+PzycjQevR0Ph0MaUC7ohGbMxDSggqU4M6olBlTBt5wriOjEqBwCqsMY",
	"UoZLzaVKmaETmuccR5p1hrO1UVws6GYT0KniIuQZS063t8wT+bzN3WlQp9tX7qQ9Z0sbnKwzKTTYg/3A",
	"ol/hWw7a4K9QCgPC/smyLOEhM1yKwVctBT6rl/mrgjmd0L8MatAM3Fs9+EkpqdxSEehQ8QyF0AmuRcrF",
	"NgH9BUwJq1+LLT1pD5mSGSjDnSJhrrRU+NeWykEFNTuOG0h1lwrlvnB2IY4pxdbU2a80/hdP9H01Us6+",
	"QmjaDPCff6HAG7ng4gQaw0PGFehr0Th3LszFeX3wXBhYgLKKyN9AtBhoSyU3LPDE91Htcx6GoPU8T4jV",
	"DxecSn3KE44aMajb99rO6Tp6wkHdCZabGITBHULUY+uVkz/SFLRmC4ucWgiXgqRcay4WRCrCxZIlPMK1",
	"nula75trVKpXWkjF/3e8CibmmmD0IVwTIQ1hSSJXEBEjSQYKz4LYMSy0G3q+Qp+kIe/dIvYwiwko76MC",
	"PI73VoXmrFuegjYszUgKTOcKIsLR4knCNYRSRJpoLkIgd4I/EMhkGJO//ZOJnKk1GQVk9OPbYUCGw4n9",
	"T+5uP/7dekJhktHb4fn43cX5EP8FDZ+7HLf6XBVIduOVr8UhE9XqeqHsylf7QMjr5Sv18E82z7TIS5g2",
	"/5YRn/M+W75pjj7gjIFnh51Vdj01oA4wO9asoNoW3XaE3Oxo8weH0RSUDRvutE8BpGLWh/WT8NETTs9D",
	"S0CzSt0bWELSJWC6NRwllAyuc241cBultYigidjt3fnGfDKep7uqgshT3MCSwwoUAifiRuIfciVAeWJq",
	"i099fZv4yJr8uPPwqvG39k29H4z/NKALy9/uuzJuk0M3hbYZAplyC8dJGU9aI1LKHq58XteDAOUVGe80",
	"Ag7dEwy39Kw4eTUlKHa9tccW3hFQDWGuuFl/Rjg6lWfAFChM6PWvn8v9fl0hrix4UZJ7WysQG5O5bMrF",
	"XLYENpujM050BiGJYM4FaGJiIGgmNWchkBmYFYCwT3HoghlYsTVhIrLPwoSDMGfkNgbyfnpNfinecyco",
	"y2cJDwkIo9aZ5MKQuVT2zZIpLnNNZiz8DUREUh4qqUEteQj6jFwbIlUYgzaKGdCWw4A2GjlGmieGZwk0",
	"59gtZUoueYQ/SChj0HzpK1Ou7TaNonKNJ2S4sbWYr8A/bm+nlXH4vCBGNKBLUC700uHZ6GyI+JAZCJZx",
	"OqEXZ8OzC0Q4M7E9vwHSrUFiSTDiWbrSClFtBSICLTXGI3Zc2SEKtPkgo/UzGHLGtF5JZSGesocbEAtE",
	"0eU4oCkX5c93HXj3Zl6cN2ZeBD2cofCBai9tfHu7Cj0fDvcF6mrcoFk3bQI67jPLK3DtlFH3lG3e7zsq",
	"nXy5D6jO05SpNZ3QBRjCSFkzGbbQaAfrvfc4bxB5DDCCBAzsouHKPq+44qngUGetZuXbGf16lbwotU8t",
	"he5XziE8wijBjO+UKyaMJs42u82NXaiMd+PaJ0k+Fjb6PXGB8y76zisqMAumCj4zZsK40J2AiOqIaZ9h",
	"nZhwDIJyTupeQw00L71sAgTjLri8Not1y7qt92XbjIy4LgoJmSDSPmVJsiYzIDpH4EFk95axBRdldLR9",
	"qm85qHXdqCqaMX4VuBM4HltwIvJ0BqqhLMZsBUZxsIGdMFwd9qyb8JQb2toP20cLcCNtonZZXr+KdoeM",
	"bu6PCXZtzbGXBW0bGZOE+P5fOD8jC74E4ToKMXPEwT2qzU6k2Av0/Un1uwXRvhX33hK6N/tsJ5gnS6Ot",
	"XbmXBS1XYxFGBKzq3IKRiZGiSmnDjZ+OB491Htv0z81XzVuLrrzk+ogvyLJFJmKVVY/ONYcsNTzZXUPd",
	"qN/XxH1hEVMK6Lb9VhJvW7AeMvBOAnNRlreFznzfwR0XQ1Mupl4YHQXfJ6puevLPjCnHoRpktJ2IGknC",
	"mAnLMY6goi8OdXkWYTDtAby98XOQNfqT/UOD19f881HTzmVdH2JNYrmyMC3XimyS09YUMyBznhhQEJHZ",
	"2qdPSUFb4SFLZATlVfFhrvuzldXYZq8L05YWbLOIDKg2a9tyQfZDW0jx6Ptc/ta66SO06ayGffH9bxZf",
	"KI13sLNhM2ZLaJJ1jzQE7jKQayJFsiYpMNd7mwEJWZI4qG4Ls81tTyROdq9bwtLUN/uzM2JnNbEnYp2m",
	"wnAE/1Z+jpmCY+uDcvoTyoSTJXN7I/CExvp1ZPca/Ze7Hne3vq/PraoSZp8PEeAmBoWeomOGlmiSlxU3",
	"MWGCwAPXtk9ki2lMkCgZH7jyyB6Oe+ma4X0cqk+mH1R3OoNH77LnqGKqXr26yJpufYP1ekut8uAW7rpj",
	"KwKyPuHvGMbVz9KnK9X8pPpK8qItLTz/naM/l9bsfXjH566gc7R/tk8r/noA5SRXVs+86t9Lx9z7dkr2",
	"+5V1bZXWFmosT3fYKSMBK6J2PwRhsM7L2/O9VObO9cVOc2qdl+8pFzzNU0sWdi/iG/eU3ReTP5UfAVTL",
	"lBfsh+8xa8mjJ1xc1it2XGJ242j0bFb4p6dHW+1cRLGP+cGjs1MP1oFT7+oPqF8hn2Ch4cuDZtvPFA5Z",
	"53QcwAahV1MV77fy01J6YfdD+XnreE4RwwWspl4c3gmlMokOvN+Kn/7goCG6X0H6ihqpRRrnIkzyqCzb",
	"XLMjq020E9Ca35g0PwP7co/Y0KCWJaJylRSfe+nJYMAyfubenhnQZrAc0c395v8BAAD//5SE5wDSMwAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
