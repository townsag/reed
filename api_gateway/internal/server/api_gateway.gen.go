//go:build go1.22

// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package server

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for PermissionLevel.
const (
	Editor PermissionLevel = "editor"
	Owner  PermissionLevel = "owner"
	Viewer PermissionLevel = "viewer"
)

// Defines values for PrincipalPrincipalType.
const (
	PrincipalPrincipalTypeGuest PrincipalPrincipalType = "guest"
	PrincipalPrincipalTypeUser  PrincipalPrincipalType = "user"
)

// CreatedAt Timestamp measured in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
type CreatedAt = int64

// Document defines model for Document.
type Document struct {
	// CreatedAt Timestamp measured in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
	CreatedAt           CreatedAt          `json:"createdAt"`
	DocumentDescription string             `json:"documentDescription"`
	DocumentId          openapi_types.UUID `json:"documentId"`
	DocumentName        string             `json:"documentName"`

	// LastModifiedAt Timestamp measured in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
	LastModifiedAt LastModifiedAt `json:"lastModifiedAt"`
}

// Error defines model for Error.
type Error struct {
	Message *string `json:"message,omitempty"`
}

// LastModifiedAt Timestamp measured in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
type LastModifiedAt = int64

// Permission defines model for Permission.
type Permission struct {
	// CreatedAt Timestamp measured in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
	CreatedAt  CreatedAt          `json:"createdAt"`
	CreatedBy  openapi_types.UUID `json:"createdBy"`
	DocumentId openapi_types.UUID `json:"documentId"`

	// LastModifiedAt Timestamp measured in milliseconds since Unix epoch (January 1, 1970, 00:00:00 UTC)
	LastModifiedAt  LastModifiedAt  `json:"lastModifiedAt"`
	PermissionLevel PermissionLevel `json:"permissionLevel"`
	Principal       Principal       `json:"principal"`
}

// PermissionLevel defines model for PermissionLevel.
type PermissionLevel string

// Principal defines model for Principal.
type Principal struct {
	PrincipalId   openapi_types.UUID     `json:"principalId"`
	PrincipalType PrincipalPrincipalType `json:"principalType"`
}

// PrincipalPrincipalType defines model for Principal.PrincipalType.
type PrincipalPrincipalType string

// User defines model for User.
type User struct {
	Email        string             `json:"email"`
	MaxDocuments int32              `json:"maxDocuments"`
	UserId       openapi_types.UUID `json:"userId"`
	UserName     string             `json:"userName"`
}

// DocumentId defines model for DocumentId.
type DocumentId = openapi_types.UUID

// PrincipalId defines model for PrincipalId.
type PrincipalId = openapi_types.UUID

// UserId defines model for UserId.
type UserId = openapi_types.UUID

// BadRequest defines model for BadRequest.
type BadRequest = Error

// LoginResponse defines model for LoginResponse.
type LoginResponse struct {
	ExpiresIn int32  `json:"expiresIn"`
	Token     string `json:"token"`
}

// Unauthenticated defines model for Unauthenticated.
type Unauthenticated = Error

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// PostAuthLoginJSONBody defines parameters for PostAuthLogin.
type PostAuthLoginJSONBody struct {
	Password string `json:"password"`
	UserName string `json:"userName"`
}

// DeleteDocumentJSONBody defines parameters for DeleteDocument.
type DeleteDocumentJSONBody struct {
	DocumentIds []openapi_types.UUID `json:"documentIds"`
}

// GetDocumentParams defines parameters for GetDocument.
type GetDocumentParams struct {
	// Cursor a cursor can optionally be supplied for pagination
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit the number of documents to retrieve in a page
	Limit *string `form:"limit,omitempty" json:"limit,omitempty"`
}

// PostDocumentJSONBody defines parameters for PostDocument.
type PostDocumentJSONBody struct {
	DocumentDescription *string            `json:"documentDescription,omitempty"`
	DocumentName        *string            `json:"documentName,omitempty"`
	UserId              openapi_types.UUID `json:"userId"`
}

// PutDocumentDocumentIdJSONBody defines parameters for PutDocumentDocumentId.
type PutDocumentDocumentIdJSONBody struct {
	DocumentDescription *string `json:"documentDescription,omitempty"`
	DocumentName        *string `json:"documentName,omitempty"`
}

// GetDocumentDocumentIdPermissionParams defines parameters for GetDocumentDocumentIdPermission.
type GetDocumentDocumentIdPermissionParams struct {
	// Cursor a cursor can optionally be supplied for pagination
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit the number of documents to retrieve in a page
	Limit *string `form:"limit,omitempty" json:"limit,omitempty"`
}

// PostDocumentDocumentIdPermissionJSONBody defines parameters for PostDocumentDocumentIdPermission.
type PostDocumentDocumentIdPermissionJSONBody struct {
	UserIdToShare openapi_types.UUID `json:"userIdToShare"`
}

// PutDocumentDocumentIdPermissionPrincipalPrincipalIdJSONBody defines parameters for PutDocumentDocumentIdPermissionPrincipalPrincipalId.
type PutDocumentDocumentIdPermissionPrincipalPrincipalIdJSONBody struct {
	PermissionLevel PermissionLevel `json:"permissionLevel"`
}

// PostUserJSONBody defines parameters for PostUser.
type PostUserJSONBody struct {
	MaxDocuments *int32              `json:"maxDocuments,omitempty"`
	Password     string              `json:"password"`
	UserEmail    openapi_types.Email `json:"userEmail"`
	UserName     string              `json:"userName"`
}

// PutUserUserIdJSONBody defines parameters for PutUserUserId.
type PutUserUserIdJSONBody struct {
	NewPassword string `json:"newPassword"`
	OldPassword string `json:"oldPassword"`
}

// PostAuthLoginJSONRequestBody defines body for PostAuthLogin for application/json ContentType.
type PostAuthLoginJSONRequestBody PostAuthLoginJSONBody

// DeleteDocumentJSONRequestBody defines body for DeleteDocument for application/json ContentType.
type DeleteDocumentJSONRequestBody DeleteDocumentJSONBody

// PostDocumentJSONRequestBody defines body for PostDocument for application/json ContentType.
type PostDocumentJSONRequestBody PostDocumentJSONBody

// PutDocumentDocumentIdJSONRequestBody defines body for PutDocumentDocumentId for application/json ContentType.
type PutDocumentDocumentIdJSONRequestBody PutDocumentDocumentIdJSONBody

// PostDocumentDocumentIdPermissionJSONRequestBody defines body for PostDocumentDocumentIdPermission for application/json ContentType.
type PostDocumentDocumentIdPermissionJSONRequestBody PostDocumentDocumentIdPermissionJSONBody

// PutDocumentDocumentIdPermissionPrincipalPrincipalIdJSONRequestBody defines body for PutDocumentDocumentIdPermissionPrincipalPrincipalId for application/json ContentType.
type PutDocumentDocumentIdPermissionPrincipalPrincipalIdJSONRequestBody PutDocumentDocumentIdPermissionPrincipalPrincipalIdJSONBody

// PostUserJSONRequestBody defines body for PostUser for application/json ContentType.
type PostUserJSONRequestBody PostUserJSONBody

// PutUserUserIdJSONRequestBody defines body for PutUserUserId for application/json ContentType.
type PutUserUserIdJSONRequestBody PutUserUserIdJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// get a token
	// (POST /auth/login)
	PostAuthLogin(w http.ResponseWriter, r *http.Request)
	// batch delete endpoint for deleting lists of documents
	// (DELETE /document)
	DeleteDocument(w http.ResponseWriter, r *http.Request)
	// get all the documents that a given user has owner permissions on
	// (GET /document)
	GetDocument(w http.ResponseWriter, r *http.Request, params GetDocumentParams)
	// create a new document for a user
	// (POST /document)
	PostDocument(w http.ResponseWriter, r *http.Request)
	// delete a document
	// (DELETE /document/{documentId})
	DeleteDocumentDocumentId(w http.ResponseWriter, r *http.Request, documentId DocumentId)
	// get one document
	// (GET /document/{documentId})
	GetDocumentDocumentId(w http.ResponseWriter, r *http.Request, documentId DocumentId)
	// update one document
	// (PUT /document/{documentId})
	PutDocumentDocumentId(w http.ResponseWriter, r *http.Request, documentId DocumentId)
	// get all the users that have permission on a document, this is only meant to be called by users that have owner permissions on that document
	// (GET /document/{documentId}/permission)
	GetDocumentDocumentIdPermission(w http.ResponseWriter, r *http.Request, documentId DocumentId, params GetDocumentDocumentIdPermissionParams)
	// create a permission on a document either by sharing the document with an existing user or creating a new guest user for that document
	// (POST /document/{documentId}/permission)
	PostDocumentDocumentIdPermission(w http.ResponseWriter, r *http.Request, documentId DocumentId)
	// delete a user or guests permissions on a document
	// (DELETE /document/{documentId}/permission/principal/{principalId})
	DeleteDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request, documentId DocumentId, principalId PrincipalId)
	// get the permission of a principal on a document
	// (GET /document/{documentId}/permission/principal/{principalId})
	GetDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request, documentId DocumentId, principalId PrincipalId)
	// update the permission level of a user or a guest on a document
	// (PUT /document/{documentId}/permission/principal/{principalId})
	PutDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request, documentId DocumentId, principalId PrincipalId)
	// create a user
	// (POST /user)
	PostUser(w http.ResponseWriter, r *http.Request)
	// deactivate a user
	// (DELETE /user/{userId})
	DeleteUserUserId(w http.ResponseWriter, r *http.Request, userId UserId)
	// get a user
	// (GET /user/{userId})
	GetUserUserId(w http.ResponseWriter, r *http.Request, userId UserId)
	// update a user including the users password
	// (PUT /user/{userId})
	PutUserUserId(w http.ResponseWriter, r *http.Request, userId UserId)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// PostAuthLogin operation middleware
func (siw *ServerInterfaceWrapper) PostAuthLogin(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuthLogin(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteDocument operation middleware
func (siw *ServerInterfaceWrapper) DeleteDocument(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDocument(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDocument operation middleware
func (siw *ServerInterfaceWrapper) GetDocument(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDocumentParams

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", r.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cursor", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDocument(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostDocument operation middleware
func (siw *ServerInterfaceWrapper) PostDocument(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDocument(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteDocumentDocumentId operation middleware
func (siw *ServerInterfaceWrapper) DeleteDocumentDocumentId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDocumentDocumentId(w, r, documentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDocumentDocumentId operation middleware
func (siw *ServerInterfaceWrapper) GetDocumentDocumentId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDocumentDocumentId(w, r, documentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PutDocumentDocumentId operation middleware
func (siw *ServerInterfaceWrapper) PutDocumentDocumentId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutDocumentDocumentId(w, r, documentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDocumentDocumentIdPermission operation middleware
func (siw *ServerInterfaceWrapper) GetDocumentDocumentIdPermission(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDocumentDocumentIdPermissionParams

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", r.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cursor", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDocumentDocumentIdPermission(w, r, documentId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostDocumentDocumentIdPermission operation middleware
func (siw *ServerInterfaceWrapper) PostDocumentDocumentIdPermission(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDocumentDocumentIdPermission(w, r, documentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteDocumentDocumentIdPermissionPrincipalPrincipalId operation middleware
func (siw *ServerInterfaceWrapper) DeleteDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	// ------------- Path parameter "principalId" -------------
	var principalId PrincipalId

	err = runtime.BindStyledParameterWithOptions("simple", "principalId", r.PathValue("principalId"), &principalId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "principalId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDocumentDocumentIdPermissionPrincipalPrincipalId(w, r, documentId, principalId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDocumentDocumentIdPermissionPrincipalPrincipalId operation middleware
func (siw *ServerInterfaceWrapper) GetDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	// ------------- Path parameter "principalId" -------------
	var principalId PrincipalId

	err = runtime.BindStyledParameterWithOptions("simple", "principalId", r.PathValue("principalId"), &principalId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "principalId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDocumentDocumentIdPermissionPrincipalPrincipalId(w, r, documentId, principalId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PutDocumentDocumentIdPermissionPrincipalPrincipalId operation middleware
func (siw *ServerInterfaceWrapper) PutDocumentDocumentIdPermissionPrincipalPrincipalId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "documentId" -------------
	var documentId DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", r.PathValue("documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	// ------------- Path parameter "principalId" -------------
	var principalId PrincipalId

	err = runtime.BindStyledParameterWithOptions("simple", "principalId", r.PathValue("principalId"), &principalId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "principalId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutDocumentDocumentIdPermissionPrincipalPrincipalId(w, r, documentId, principalId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostUser operation middleware
func (siw *ServerInterfaceWrapper) PostUser(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostUser(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteUserUserId operation middleware
func (siw *ServerInterfaceWrapper) DeleteUserUserId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId UserId

	err = runtime.BindStyledParameterWithOptions("simple", "userId", r.PathValue("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "userId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUserUserId(w, r, userId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetUserUserId operation middleware
func (siw *ServerInterfaceWrapper) GetUserUserId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId UserId

	err = runtime.BindStyledParameterWithOptions("simple", "userId", r.PathValue("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "userId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUserUserId(w, r, userId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PutUserUserId operation middleware
func (siw *ServerInterfaceWrapper) PutUserUserId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId UserId

	err = runtime.BindStyledParameterWithOptions("simple", "userId", r.PathValue("userId"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "userId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutUserUserId(w, r, userId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("POST "+options.BaseURL+"/auth/login", wrapper.PostAuthLogin)
	m.HandleFunc("DELETE "+options.BaseURL+"/document", wrapper.DeleteDocument)
	m.HandleFunc("GET "+options.BaseURL+"/document", wrapper.GetDocument)
	m.HandleFunc("POST "+options.BaseURL+"/document", wrapper.PostDocument)
	m.HandleFunc("DELETE "+options.BaseURL+"/document/{documentId}", wrapper.DeleteDocumentDocumentId)
	m.HandleFunc("GET "+options.BaseURL+"/document/{documentId}", wrapper.GetDocumentDocumentId)
	m.HandleFunc("PUT "+options.BaseURL+"/document/{documentId}", wrapper.PutDocumentDocumentId)
	m.HandleFunc("GET "+options.BaseURL+"/document/{documentId}/permission", wrapper.GetDocumentDocumentIdPermission)
	m.HandleFunc("POST "+options.BaseURL+"/document/{documentId}/permission", wrapper.PostDocumentDocumentIdPermission)
	m.HandleFunc("DELETE "+options.BaseURL+"/document/{documentId}/permission/principal/{principalId}", wrapper.DeleteDocumentDocumentIdPermissionPrincipalPrincipalId)
	m.HandleFunc("GET "+options.BaseURL+"/document/{documentId}/permission/principal/{principalId}", wrapper.GetDocumentDocumentIdPermissionPrincipalPrincipalId)
	m.HandleFunc("PUT "+options.BaseURL+"/document/{documentId}/permission/principal/{principalId}", wrapper.PutDocumentDocumentIdPermissionPrincipalPrincipalId)
	m.HandleFunc("POST "+options.BaseURL+"/user", wrapper.PostUser)
	m.HandleFunc("DELETE "+options.BaseURL+"/user/{userId}", wrapper.DeleteUserUserId)
	m.HandleFunc("GET "+options.BaseURL+"/user/{userId}", wrapper.GetUserUserId)
	m.HandleFunc("PUT "+options.BaseURL+"/user/{userId}", wrapper.PutUserUserId)

	return m
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
