// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const changeUserPassword = `-- name: ChangeUserPassword :one
UPDATE users
SET hashed_password = $1, last_modified = CURRENT_TIMESTAMP
WHERE id = $2
RETURNING id
`

type ChangeUserPasswordParams struct {
	HashedPassword string
	ID             pgtype.UUID
}

func (q *Queries) ChangeUserPassword(ctx context.Context, arg ChangeUserPasswordParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, changeUserPassword, arg.HashedPassword, arg.ID)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (id, user_name, email, max_documents, hashed_password)
VALUES ($1, $2, $3, $4, $5)
`

type CreateUserParams struct {
	ID             pgtype.UUID
	UserName       string
	Email          string
	MaxDocuments   pgtype.Int4
	HashedPassword string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser,
		arg.ID,
		arg.UserName,
		arg.Email,
		arg.MaxDocuments,
		arg.HashedPassword,
	)
	return err
}

const deactivateUser = `-- name: DeactivateUser :one
UPDATE users
SET is_active = FALSE, last_modified = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id
`

func (q *Queries) DeactivateUser(ctx context.Context, id pgtype.UUID) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, deactivateUser, id)
	err := row.Scan(&id)
	return id, err
}

const getHashedPassword = `-- name: GetHashedPassword :one

SELECT id, hashed_password
FROM users
WHERE user_name = $1
`

type GetHashedPasswordRow struct {
	ID             pgtype.UUID
	HashedPassword string
}

// this allows us to read and update the password with serializability guarantees
// reading the row with for update locks the record at the row level so that
// other operations cannot update, delete, or select for update on that row
func (q *Queries) GetHashedPassword(ctx context.Context, userName string) (GetHashedPasswordRow, error) {
	row := q.db.QueryRow(ctx, getHashedPassword, userName)
	var i GetHashedPasswordRow
	err := row.Scan(&i.ID, &i.HashedPassword)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, user_name, email, max_documents, hashed_password, is_active, created_at, last_modified
FROM users
WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.Email,
		&i.MaxDocuments,
		&i.HashedPassword,
		&i.IsActive,
		&i.CreatedAt,
		&i.LastModified,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id, user_name, email, max_documents, hashed_password, is_active, created_at, last_modified 
FROM users 
WHERE id = $1
`

func (q *Queries) GetUserById(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.Email,
		&i.MaxDocuments,
		&i.HashedPassword,
		&i.IsActive,
		&i.CreatedAt,
		&i.LastModified,
	)
	return i, err
}

const getUserForUpdate = `-- name: GetUserForUpdate :one
SELECT id, user_name, email, max_documents, hashed_password, is_active, created_at, last_modified 
FROM users 
WHERE id = $1
FOR UPDATE
`

func (q *Queries) GetUserForUpdate(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserForUpdate, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.Email,
		&i.MaxDocuments,
		&i.HashedPassword,
		&i.IsActive,
		&i.CreatedAt,
		&i.LastModified,
	)
	return i, err
}
