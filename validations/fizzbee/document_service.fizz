---
# Temporarily disable deadlock detection
deadlock_detection: false
---


role DocumentService:
    action Init:
        self.documents = set()
        self.permissions = dict()

    action CreateDocument:
        highestDocumentId += 1
        self.documents.add(highestDocumentId)

    action CreatePermission:
        # choose a random document
        documentId = any documents 
        # choose a random user
        userId = any users
        if documentId not in self.permissions:
            self.permissions[documentId] = set()
        self.permissions[documentId].add(userId)
            
    atomic action DeleteDocument:
        # choose a random document
        documentId = any documents
        self.documents.remove(documentId)
        if documentId in self.permissions:
            for userId in self.permissions[documentId]:
                # use atomic actions to indicate that if we are going to delete a permission
                # we are also going to write an event to the queue
                fifoQueue.append((documentId, userId, True))
            del self.permissions[documentId]

    atomic action DeletePermission:
        # choose a random document
        documentId = any documents 
        # choose a random user
        userId = any users
        if documentId in self.permissions and userId in self.permissions[documentId]:
            self.permissions[documentId].remove(userId)
            # use atomic actions to indicate that if we are going to delete a permission 
            # we are also going to write an event to the queue
            fifoQueue.append((documentId, userId, True))
    
    func CheckPermission(documentId, userId):
        return documentId in self.permissions and userId in self.permissions[documentId]

role MessageProxyService:
    action Init:
        # connections is a set of userId, documentId tuples
        # this represent the stateful connections that an instance of the
        # message proxy service can make with clients 
        self.connections = set()
    
    action Connect:
        # choose a random document
        documentId = any documents
        # choose a random user
        userId = any users
        # check that the user has permission on that document
        # if so add the connection of that user to that document
        if documentService.CheckPermission(documentId, userId):
            self.connections.add((documentId, userId))
            
    func receivePermissionUpdate(documentId, userId, isRevoked):
        # TODO: we need to explicitly model the fact that the message proxy service
        #       only starts listening for permission update events when it has
        #       already made a connection for that documentId
        if isRevoked:
            self.connections.remove((documentId, userId))

# we use atomic here to indicate that message delivery is guaranteed
# presumably atomic and serial block modifiers are mutually exclusive
# meaning that there is no way we could pop a message from the queue and
# then fail to process it
atomic action ReceivePermissionUpdate:
    if fifoQueue:
        documentId, userId, isRevoked = fifoQueue[0]
        messageProxyService.receivePermissionUpdate(documentId, userId, isRevoked)
        oneof:
            fifoQueue.pop(0)
            pass


# use atomic actions / functions to indicate that the sending of messages between the document
# service and the message proxy service has at least once semantics 
    

action Init:
    # init is used to create system scoped state variables
    # these can be accessed in any of the functions / actions of the roles
    documentService = DocumentService()
    messageProxyService = MessageProxyService()
    # use a fifo queue for now
    # when we introduce the idea of partitioning the queue on document id
    # we will have to represent the different queue partitions somehow
    # it may be useful to make a map of lists and maintain offsets for each
    # consumer instead of deleting from the queue
    fifoQueue = []
    highestDocumentId = -1
    users = ["a", "b", "c"]
    documents = ["1", "2", "3"]

# always assertion NoPermissionsOnMissingDoc:
#     return none([permissionDocId not in DocumentService.documents for permissionDocId, permissions in DocumentService.permissions])

# how do I model lost writes? I want to make sure that updates to the permission are eventually reflected? this is a liveness guarantee

# use safety guarantee to indicate that there should be no way that a client can connect to a document that they do not
# have permissions on
# safety guarantees are created using the the always keyword

# use liveness guarantee to indicate that if a client looses permissions on a document they should be eventually disconnected
# liveness guarantees are created using the eventually keyword
# use either always eventually: indicates that given some amount of time the behavior will reach the desired state
# or eventually always: indicates that the behavior will reach the desired state and stay there
